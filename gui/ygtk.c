/* warning - this file is automatically generated! edit ygtk.c.in instead! */
#line 2 "ygtk.c.in"
#line 5 "ygtk.c.in"

/* ygtk.c - a lightweight Lua GTK+ binding
 *
 * Copyright (c) 2012 Sean Bolton and others.
 *
 * Portions of this code come from lua-gnome, copyright (C) 2005,
 * 2007, 2008 Wolfgang Oertl under the Lesser GNU Public License
 * version 2.1.
 *
 * Portions of this code come from Lua 5.1, copyright (C)1994-2008
 * Lua.org, PUC-Rio, under an MIT/Expat license.
 *
 * Thanks to PyGTK (James Henstridge, et al.) for inspiration.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License, version 2.1, as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA 02110-1301 USA.
 */

/* Why another Lua GTK+ binding? Well, if lgob or lgi had existed when I
 * started this, I probably would have just used one of them.  But they
 * didn't, and at the time, lgui/lobj and lua-gnome each suffered from
 * some combination of the following:
 *
 * - poor or broken resource management
 * - too many deviations from the GTK+ API (parameter name changes,
 *     parameter order changes) with no documentation of the deviations
 * - difficult to build
 * - too inclusive (bloated) for my needs
 * - overly restrictive license
 *
 * Now, to be fair, here are some of ygtk's shortcomings:
 *
 * - very incomplete coverage of GTK+ API
 * - minimal-to-no type safety: pass the wrong argument to a ygtk
 *     function, and you will crash, just as in C
 * - occasionally deviates from the GTK+ API...
 * - ...with no documentation
 *
 * Unless you need a very minimal, LGPLv2.1-licensed GTK+ binding,
 * don't use this, use lgi, lgob or lua-gnome. Seriously.
 */

#include <stdlib.h>
#include <stdio.h>   /* would be nice to get rid of this */
#include <stdarg.h>
#include <string.h>
#include <math.h>    /* for floor in ycairo_context_set_source_hsv() */

#define LUA_LIB

#ifdef YGTK_STANDALONE
#include "lua.h"
#include "lauxlib.h"
#else
#include <why/lua.h>
#include <why/lauxlib.h>
#endif

#include <glib.h>
#line 76 "ygtk.c.in"
#include <cairo.h>
#line 78 "ygtk.c.in"
#include <pango/pango.h>
#include <gtk/gtk.h>

#ifdef YGTK_USE_GTK_CONTROL
#include "gtkcontrolpanel.h"
#include "gtkcontrol.h"
#endif
#ifdef YGTK_USE_GTK_KNOB
#include "gtkknob.h"
#endif

#include "ygtk.h"

#ifdef Y_WANT_GC_DEBUG
#define y_gc_debug(x, ...) fprintf(stderr, x, __VA_ARGS__)
#else
#define y_gc_debug(...) ((void)0)
#endif

typedef struct _ygtk_class_data {
    const char *class;
    const char *lib;
    const char *table;
    struct _ygtk_class_data *parent;
} ygtk_class_data;

static GQuark ygtk_class_pointer_quark;

typedef struct _ygtk_enum_data {
    const char *name;
    int value;
} ygtk_enum_data;

ygtk_object *ygtk_make_object(lua_State *L, GObject *o, ygtk_class_data *class); /* forward */

#if LUA_VERSION_NUM >= 502
#define ygtk_pushglobaltable(L)     lua_pushglobaltable(L)
#define ygtk_setfuncs0(L, lib)      luaL_setfuncs(L, (lib), 0)
/* ygtk_typeerror defined below */
#else
#define ygtk_pushglobaltable(L)     lua_pushvalue(L, LUA_GLOBALSINDEX)
#define ygtk_setfuncs0(L, lib)      luaL_register(L, NULL, (lib))
#define ygtk_typeerror              luaL_typerror
#define lua_rawlen(L,i)             lua_objlen(L, (i))
#endif

/* ---- begin code adapted from Lua 5.1.4 src/lauxlib.c ---- */

/* The next two functions were adapted from Lua 5.1, which is copyright
 * and licensed as follows:
 *
 *    Copyright (C) 1994-2008 Lua.org, PUC-Rio.  All rights reserved.
 *
 *    Permission is hereby granted, free of charge, to any person obtaining
 *    a copy of this software and associated documentation files (the
 *    "Software"), to deal in the Software without restriction, including
 *    without limitation the rights to use, copy, modify, merge, publish,
 *    distribute, sublicense, and/or sell copies of the Software, and to
 *    permit persons to whom the Software is furnished to do so, subject to
 *    the following conditions:
 *
 *    The above copyright notice and this permission notice shall be
 *    included in all copies or substantial portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 *    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 *    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 *    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 *    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#if LUA_VERSION_NUM >= 502
int ygtk_typeerror (lua_State *L, int narg, const char *tname)
{
    const char *msg = lua_pushfstring(L, "%s expected, got %s",
                                      tname, luaL_typename(L, narg));
    return luaL_argerror(L, narg, msg);
}
#endif

/* ygtk_findtable
 *
 * Search for the table 'table' (e.g. 'gtk' or 'gtk.button'), starting from the
 * global environment. If found, return with the table on the top of the stack.
 * If the table is not found, but all of its parents are (e.g. 'gtk.button' is
 * not found, but 'gtk' is), and if 'create' is true, then create the table and
 * return it on the top of the stack.  Otherwise, blow an error.
 *
 * This function is based on Lua 5.1's luaL_findtable() (in lauxlib.c), which
 * Roberto said was "more for internal use", and which, sure enough, went away
 * in Lua 5.2.
 */
void
ygtk_findtable(lua_State *L, const char *table, int create)
{
  const char *fname = table;
  const char *e;
  ygtk_pushglobaltable(L);
  do {
    e = strchr(fname, '.');
    if (e == NULL) e = fname + strlen(fname);
    lua_pushlstring(L, fname, e - fname);
    lua_rawget(L, -2);
    if (lua_isnil(L, -1)) {  /* no such field? */
      lua_pop(L, 1);  /* remove this nil */
      if ((*e == '.') || !create) {
        luaL_error(L, "can't find ygtk class table '%s'", table);
      } else {
        lua_newtable(L); /* new table for field */
        lua_pushlstring(L, fname, e - fname);
        lua_pushvalue(L, -2);
        lua_settable(L, -4);  /* set new table into field */
      }
    }
    else if (!lua_istable(L, -1)) {  /* field has a non-table value? */
      lua_pop(L, 2);  /* remove table and value */
      luaL_error(L, "bad ygtk class table in '%s'", table);
    }
    lua_remove(L, -2);  /* remove previous table */
    fname = e + 1;
  } while (*e == '.');
}

/* ---- end code adapted from Lua 5.1.4 src/lauxlib.c ---- */

/* ygtk_build_simple_class
 *
 * Build a simple ygtk class table with no inheritance, setting __index
 * to point to the table itself.
 */
static void
ygtk_build_simple_class(lua_State *L, const char *class,
                        const luaL_Reg *lib)
{
    /* push class table, creating it if needed;  -- classtable */
    ygtk_findtable(L, class, 1);
    
    /* 'classtable.__index = classtable' */
    lua_pushliteral(L, "__index");  /* -- classtable "__index" */
    lua_pushvalue(L, -2);           /* -- classtable "__index" classtable */
    lua_rawset(L, -3);              /* -- classtable */

    /* now register the class functions */
    ygtk_setfuncs0(L, lib);         /* -- classtable */
    lua_remove(L, -1);              /* -- */
}

/* ygtk_make_simple_object
 *
 * Create a new userdata to hold the object, and set its metatable.
 */
ygtk_object *
ygtk_make_simple_object(lua_State *L, gpointer o, const char *class)
{
    ygtk_object *u;

    u = lua_newuserdata(L, sizeof(ygtk_object));  /* -- userdata */
    u->instance = o;
    ygtk_findtable(L, class, 0);                  /* -- userdata class_table */
    lua_setmetatable(L, -2);                      /* -- userdata */

    return u;
}

/* ygtk_checkuserdata
 *
 * Throw type error if argument at index is not a userdata, otherwise,
 * return a pointer to the userdata.
 */
void *
ygtk_checkuserdata(lua_State *L, int index)
{
    void *p = lua_touserdata(L, index);
    if (p == NULL)
      ygtk_typeerror(L, index, lua_typename(L, LUA_TUSERDATA));
    return p;
}

/* ygtk_lua_to_gvalue
 *
 * Convert the Lua value at index to the specified GType and store it in the
 * supplied GValue. The GValue must either be uninitialized (zeroed) or
 * initialized with the correct GType.
 */
static void
ygtk_lua_to_gvalue(lua_State *L, int index, GType gtype, GValue *gv)
{
    if (!G_VALUE_HOLDS(gv, gtype))  /* assume unitialized */
        g_value_init(gv, gtype);
 
    switch (G_TYPE_FUNDAMENTAL(gtype)) {

      /* G_TYPE_NONE */
      /* G_TYPE_INTERFACE */
      /* G_TYPE_CHAR */
      /* G_TYPE_UCHAR */

      case G_TYPE_BOOLEAN:
        g_value_set_boolean(gv, lua_toboolean(L, index));
        return;

      case G_TYPE_INT:
        g_value_set_int(gv, (gint)luaL_checkinteger(L, index));
        return;

      case G_TYPE_UINT:
        g_value_set_uint(gv, (guint)luaL_checkinteger(L, index));
        return;

      case G_TYPE_LONG:
        g_value_set_long(gv, (glong)luaL_checkinteger(L, index));
        return;

      case G_TYPE_ULONG:
        g_value_set_ulong(gv, (gulong)luaL_checkinteger(L, index));
        return;
 
      case G_TYPE_INT64:
        g_value_set_int64(gv, (gint64)luaL_checkinteger(L, index));
        return;

      case G_TYPE_UINT64:
        g_value_set_uint64(gv, (guint64)luaL_checkinteger(L, index));
        return;

      case G_TYPE_ENUM:
        g_value_set_enum(gv, (gint)luaL_checkinteger(L, index));
        return;

      case G_TYPE_FLAGS:
        g_value_set_flags(gv, (guint)luaL_checkinteger(L, index));
        return;

      case G_TYPE_FLOAT:
        g_value_set_float(gv, (gfloat)luaL_checknumber(L, index));
        return;
	
      case G_TYPE_DOUBLE:
        g_value_set_double(gv, luaL_checknumber(L, index));
        return;

      case G_TYPE_STRING:
        /* lua_tolstring might convert a numeric value to a string, so
         * check first. */
        luaL_checktype(L, index, LUA_TSTRING);
        g_value_set_string(gv, lua_tolstring(L, index, NULL));
        return;

      /* G_TYPE_POINTER */

      case G_TYPE_BOXED:
        if (gtype == G_TYPE_STRV) {
            /* convert a table of strings into a boxed GStrv, which is nice for e.g.
             * about_dialog:set("authors", {"author1", "author2"}) */
            GStrv strv;
            int i = 0;

            if (!lua_istable(L, index)) {
                ygtk_typeerror(L, index, "table of strings");
                /* does not return */
            }

            strv = g_malloc0(sizeof(gchar *) * (lua_rawlen(L, index) + 1));
            do {
                lua_rawgeti(L, index, i + 1);
                if (lua_isstring(L, -1))
                    strv[i] = g_strdup(lua_tostring(L, -1));
                else if (!lua_isnil(L, -1)) {
                    ygtk_typeerror(L, index, "table of strings");
                    /* does not return */
                }
                lua_remove(L, -1);
            } while (strv[i++]);
            g_value_take_boxed(gv, (gconstpointer)strv);
            return;
        }
        break;

      /* G_TYPE_PARAM */

      case G_TYPE_OBJECT:
        {   ygtk_object *o = lua_touserdata(L, index);
            g_value_set_object(gv, G_OBJECT(o->instance));
        }
        return;

      /* G_TYPE_VARIANT */
    }

    luaL_error(L, "ygtk_lua_to_gvalue: can't convert from Lua type '%s' to GType '%s'\n"
               "(fundamental GType is '%s', is %sa GObject)",
               lua_typename(L, lua_type(L, index)), g_type_name(gtype),
               g_type_name(G_TYPE_FUNDAMENTAL(gtype)),
               g_type_is_a(gtype, G_TYPE_OBJECT) ? "" : "not ");
}

/* ygtk_register
 *
 * Make a new table, store it as the global 'libname', and populate it with
 * functions from 'l'.  Like luaL_register(), but without the package
 * side-effects.
 */
void ygtk_register(lua_State *L, const char *libname, const luaL_Reg *l)
{
    lua_newtable(L);
    lua_pushvalue(L, -1);
    lua_setglobal(L, libname);
    ygtk_setfuncs0(L, l);
}

/* ygtk_set_enums
 *
 * Store the enums into the table on the top of the stack.
 */
void ygtk_set_enums(lua_State *L, const ygtk_enum_data *enums)
{
    int i;

    for (i = 0; enums[i].name != NULL; i++) {
	lua_pushinteger(L, enums[i].value);
	lua_setfield(L, -2, enums[i].name);
    }
}

/* ==== glib / gobject ==== */

/* ---- begin code adapted from lua-gnome-2008-12-01 src/gnome/gvalue.c ---- */

/* The GValue at *gv is of a fundamental type.  Push the appropriate value
 * on the Lua stack.  If the type is not handled, a Lua error is raised.
 */
static void _push_gvalue_fundamental(lua_State *L, const GValue *gv)
{
    GType type = G_VALUE_TYPE(gv);
    gchar c;

    /* see /usr/include/glib-2.0/gobject/gtype.h for type numbers. */
    switch (G_TYPE_FUNDAMENTAL(type)) {
        case G_TYPE_INVALID:
            lua_pushnil(L);
            return;

        case G_TYPE_NONE:
            fprintf(stderr, "_push_gvalue_fundamental: strange... an argument of type NONE?\n");
            return;

        /* missing: G_TYPE_INTERFACE */

        case G_TYPE_CHAR:;
            c = gv->data[0].v_int;
            lua_pushlstring(L, &c, 1);
            return;

        case G_TYPE_UCHAR:;
            c = (gchar) gv->data[0].v_uint;
            lua_pushlstring(L, &c, 1);
            return;

        case G_TYPE_BOOLEAN:
            lua_pushboolean(L, gv->data[0].v_int);
            return;

        case G_TYPE_INT:
            lua_pushnumber(L, gv->data[0].v_int);
            return;

        case G_TYPE_UINT:
            lua_pushnumber(L, gv->data[0].v_uint);
            return;

        case G_TYPE_LONG:
            lua_pushnumber(L, gv->data[0].v_long);
            return;

        case G_TYPE_ULONG:
            lua_pushnumber(L, gv->data[0].v_ulong);
            return;

        case G_TYPE_INT64:
            lua_pushnumber(L, gv->data[0].v_int64);
            return;

        case G_TYPE_UINT64:
            lua_pushnumber(L, gv->data[0].v_uint64);
            return;

        /* try to determine the correct ENUM/FLAG type. */
        // case G_TYPE_ENUM:
        // case G_TYPE_FLAGS:;
        //     if (G_TYPE_IS_DERIVED(type)) {
        //         typespec_t ts = lg_find_struct(L, g_type_name(type), 0);
        //         if (ts.value) {
        //             lg_push_constant(L, ts, gv->data[0].v_int);
        //             return;
        //         }
        //     }
        //     lua_pushnumber(L, gv->data[0].v_int);
        //     return;

        case G_TYPE_FLOAT:
            lua_pushnumber(L, gv->data[0].v_float);
            return;

        case G_TYPE_DOUBLE:
            lua_pushnumber(L, gv->data[0].v_double);
            return;

        case G_TYPE_STRING:
            lua_pushstring(L, (char*) gv->data[0].v_pointer);
            return;

        case G_TYPE_POINTER:
            /* Some opaque structure.  This is very seldom and it is
             * not useful to try to override it.  There's a reason for
             * parameters being opaque.... */
            lua_pushlightuserdata(L, (void*) gv->data[0].v_pointer);
            return;

        /* missing: G_TYPE_BOXED */
        /* missing: G_TYPE_PARAM */
        /* missing: G_TYPE_OBJECT */

        default:
            luaL_error(L, "_push_gvalue_fundamental: unhandled fundamental "
                "type %d\n", (int) type >> 2);
    }
}

/*
 * A parameter for a callback must be pushed onto the stack, or a return
 * value from Gtk converted to a Lua type.  A value is always pushed; in the
 * case of error, nil.
 *
 * @param L   Lua State
 * @param gv  The GValue to be pushed
 */
static void
yg_gvalue_to_lua(lua_State *L, const GValue *gv)
{
    GType gtype = G_VALUE_TYPE(gv);
    const char *name;

    if (!gv)
        luaL_error(L, "yg_gvalue_to_lua called with NULL data");

    /* fundamental types (char, int, ...) handled here */
    if (G_TYPE_IS_FUNDAMENTAL(gtype)) {
        _push_gvalue_fundamental(L, gv);
        return;
    }

    /* enum and flags also handled there. */
    switch (G_TYPE_FUNDAMENTAL(gtype)) {
        case G_TYPE_ENUM:
        case G_TYPE_FLAGS:
            _push_gvalue_fundamental(L, gv);
            return;
    }

    /* GBoxed: push a GValue userdata containing a copy of gv */
    if (G_TYPE_FUNDAMENTAL(gtype) == G_TYPE_BOXED) {
        const char *name = g_type_name(gtype);
        GValue *gvbox;

        if (gtype != GDK_TYPE_EVENT && gtype != GDK_TYPE_RECTANGLE)
            fprintf(stderr, "*** yg_gvalue_to_lua WARNING: pushing a '%s', make sure copy/gc is correct!\n", name);
            /* ... which means this is likely happening during a callback, and we're about to create
             * a copy which will hang around after the callback until it is collected, so we better
             * not hold references to anything which will go away in the mean time. */
#line 554 "ygtk.c.in"

        gvbox = (GValue *)lua_newuserdata(L, sizeof(GValue));
        memset(gvbox, 0, sizeof(GValue));
        g_value_init(gvbox, gtype);
        g_value_copy(gv, gvbox);

        ygtk_findtable(L, "g.boxed", 0);  /* -- userdata g.boxed */
        lua_setmetatable(L, -2);          /* -- userdata */
        return;
    }

    /* If this type is derived from GObject, then check if it has our class pointer
     * stored as qdata. */
    if (g_type_is_a(gtype, G_TYPE_OBJECT)) {
        GObject *o = g_value_get_object(gv);
        ygtk_class_data *class = g_type_get_qdata(G_OBJECT_TYPE(o), ygtk_class_pointer_quark);
        if (class) {
            g_object_ref(o);
            ygtk_make_object(L, o, class);
            return;
        }
    }

    name = g_type_name(gtype);
    if (!name)
         fprintf(stderr, "yg_gvalue_to_lua: unhandled unknown type %ld\n", (gulong)gtype);
    else {
        if (g_type_is_a(gtype, G_TYPE_OBJECT)) {
            fprintf(stderr, "yg_gvalue_to_lua: unhandled type %s is a GObject (with no qdata associated)\n", name);
        } else {
            const char *fname = g_type_name(G_TYPE_FUNDAMENTAL(gtype));
            fprintf(stderr, "yg_gvalue_to_lua: unhandled type %s is NOT a GObject, fundamental type is %s\n", name, fname);
        }
    }

    lua_pushnil(L);
}

/* ---- end code from lua-gnome-2008-12-01 src/gnome/gvalue.c ---- */

typedef struct _ygtk_closure {
    GClosure closure;
    lua_State *L;
    int object_ref;
    int handler_ref;
    int data_ref;
} ygtk_closure;

static void
ygtk_closure_finalize(gpointer data, GClosure *closure)
{
    ygtk_closure *yc = (ygtk_closure *)data;

    luaL_unref(yc->L, LUA_REGISTRYINDEX, yc->object_ref);
    luaL_unref(yc->L, LUA_REGISTRYINDEX, yc->handler_ref);
    if (yc->data_ref != LUA_NOREF)
        luaL_unref(yc->L, LUA_REGISTRYINDEX, yc->data_ref);
}

static void
ygtk_closure_marshal(GClosure *closure,
                     GValue *return_value,
                     guint n_param_values,
                     const GValue *param_values,
                     gpointer invocation_hint,
                     gpointer marshal_data)
{
    ygtk_closure *yc = (ygtk_closure *)closure;
    lua_State *L = yc->L;
    int i;
    GType return_type;
    int top = lua_gettop(L);

    /* push handler function */
    lua_rawgeti(L, LUA_REGISTRYINDEX, yc->handler_ref);

    /* push the parameters (signal object should be first) */
    for (i = 0; i < n_param_values; i++) {
        yg_gvalue_to_lua(L, &param_values[i]);
    }
    
    /* push the 'user_data' argument from connect */
    if (yc->data_ref != LUA_NOREF) {
        lua_rawgeti(L, LUA_REGISTRYINDEX, yc->data_ref);
        n_param_values++;
    }

    /* make the call, and handle result */
    return_type = (return_value == NULL ? G_TYPE_NONE : G_VALUE_TYPE(return_value));
    if (return_type == G_TYPE_NONE) {
        lua_call(L, n_param_values, 0);
    } else {
        lua_call(L, n_param_values, 1);
        ygtk_lua_to_gvalue(L, -1, return_type, return_value);
    }

    /* clean stack (probably unnecessary) */
    lua_settop(L, top);
}

/* ---- begin code from lua-gnome-2008-12-01 src/glib/callback.c ---- */

/* _connect
 *
 * Connect a signal to a Lua function.
 *
 * @luaparam object
 * @luaparam signal_name  Name of the signal, like "clicked"
 * @luaparam handler      A Lua function (the callback)
 * @luaparam user_data    (optional) extra parameter to the callback
 *
 * @luareturn  The handler id, which can be used to disconnect the signal.
 */
static int
_connect(lua_State *L, gboolean after)
{
    ygtk_object *w;
    const char *signame;
    guint signal_id;
    GClosure *closure;
    ygtk_closure *yc;
    gulong handler_id;

    luaL_checktype(L, 3, LUA_TFUNCTION);

    /* get the object */
    w = (ygtk_object *) ygtk_checkuserdata(L, 1);

    /* determine the signal */
    signame = luaL_checkstring(L, 2);
    signal_id = g_signal_lookup(signame, G_OBJECT_TYPE(w->instance));
    if (!signal_id)
        luaL_error(L, "Can't find signal '%s'", signame);

    closure = g_closure_new_simple(sizeof(ygtk_closure), NULL);
    yc = (ygtk_closure *)closure;
    yc->L = L;

    /* stack: object signame func [user_data] */

    /* make a reference to the object - to avoid it being garbage collected. */
    lua_pushvalue(L, 1);
    yc->object_ref = luaL_ref(L, LUA_REGISTRYINDEX);

    /* make a reference to the function, and store it. */
    lua_pushvalue(L, 3);
    yc->handler_ref = luaL_ref(L, LUA_REGISTRYINDEX);

    /* if there is a user_data argument, store a reference to it.  When called
     * with NIL as user_data, ignore it. */
    if (lua_isnoneornil(L, 4))
	yc->data_ref = LUA_NOREF;
    else
	yc->data_ref = luaL_ref(L, LUA_REGISTRYINDEX);

    g_closure_add_finalize_notifier(closure, yc, ygtk_closure_finalize);
    g_closure_set_marshal(closure, ygtk_closure_marshal);
    handler_id = g_signal_connect_closure(w->instance, signame, closure, after);

    lua_pushnumber(L, handler_id);

    return 1;
}

static int
yg_signal_connect(lua_State *L)
{
    return _connect(L, FALSE);
}

static int
yg_signal_connect_after(lua_State *L)
{
    return _connect(L, TRUE);
}

/* ---- end code from lua-gnome-2008-12-01 src/glib/callback.c ---- */

/* ---- begin code from lua-gtk-0.9 src/override.c ---- */

struct timeout_info {
    lua_State *L;
    int function_ref;
    int arg_ref;       /* ref to an extra argument, or 0 */
};

/*
 * Callback functions for timeout and idle events. This runs in the
 * lua_State that was used to call glib_connect with, and therefore probably
 * uses the stack of the main function, which mustn't be modified.
 */
static int _timeout_func(void *data)
{
    struct timeout_info *td = (struct timeout_info*) data;
    lua_State *L = td->L;
    int stack_top = lua_gettop(L);
    int args_cnt = 0;
    int rc;

    /* push callback function */
    lua_rawgeti(L, LUA_REGISTRYINDEX, td->function_ref);
    if (lua_isnil(L, -1)) {
        lua_pop(L, 1);
        return luaL_error(L, "timeout/idle handler not found");
    }
	
    /* push extra argument, if any */
    if (td->arg_ref != LUA_NOREF) {
	lua_rawgeti(L, LUA_REGISTRYINDEX, td->arg_ref);
	args_cnt ++;
    }

    lua_call(L, args_cnt, 1);

    rc = lua_toboolean(L, -1);

    /* make sure the stack is back to the original state */
    lua_settop(L, stack_top);

    return rc;
}

/*
 * Allocate a struct timeout_info for timeout and idle callbacks.
 *
 * The stack contains a function and zero or one arguments starting at
 * the given index.
 */
static struct timeout_info *_build_timeout_callback(lua_State *L, int index)
{
    int stack_top = lua_gettop(L);
    struct timeout_info *td;

    luaL_checktype(L, index, LUA_TFUNCTION);
    td = g_malloc(sizeof(struct timeout_info));
    td->L = L;
    lua_pushvalue(L, index);
    td->function_ref = luaL_ref(L, LUA_REGISTRYINDEX);

    /* collect extra argument if present and not nil */
    if (stack_top >= index + 1 && lua_type(L, index + 1) != LUA_TNIL) {
	lua_pushvalue(L, index + 1);
	td->arg_ref = luaL_ref(L, LUA_REGISTRYINDEX);
    } else {
	td->arg_ref = LUA_NOREF;
    }

    return td;
}

static void _free_timeout_info(gpointer data);  /* forward */

/*
 * Add a timeout handler.  The handler will receive the "data" argument
 * as argument.
 *
 * @luaparam interval  sleep time in ms
 * @luaparam function  the function to call
 * @luaparam data  extra argument of any data type to pass to the callback.
 * @luareturn  An ID of the idle handler.
 */
static int
yg_timeout_add(lua_State *L)
{
    int interval = luaL_checkint(L, 1);
    struct timeout_info *td = _build_timeout_callback(L, 2);
    guint id = g_timeout_add_full(G_PRIORITY_DEFAULT, interval, _timeout_func, td,
                                  _free_timeout_info);
    lua_pushnumber(L, id);
    return 1;
}


/**
 * Add an idle handler.
 *
 * @luaparam callback
 * @luaparam data  An extra parameter of any data type for the callback
 * @luareturn  An ID of the idle handler.
 */
static int
yg_idle_add(lua_State *L)
{
    luaL_checktype(L, 1, LUA_TFUNCTION);
    struct timeout_info *td = _build_timeout_callback(L, 1);
    guint id = g_idle_add_full(G_PRIORITY_DEFAULT_IDLE, _timeout_func, td, _free_timeout_info);
    lua_pushnumber(L, id);
    return 1;
}

/* ---- end code from lua-gtk-0.9 src/override.c ---- */

/* ---- begin code adapted from lua-gnome-2008-12-01 src/glib/callback.c ---- */

/*
 * Free memory on timeout or idle source destruction.
 *
 * The struct timeout_info contains references to entries in the registry
 * of the Lua state.  They must be unreferenced, then the structure itself
 * is freed.
 *
 * This assumes that the Lua state still exists.
 */
static void
_free_timeout_info(gpointer data)
{
    /* data is a struct timeout_info.  It contains references, free them.
     * see _build_timeout_callback(). */
    struct timeout_info *to_info = (struct timeout_info*) data;
    y_gc_debug("_free_timeout_info called for %p\n", to_info);
    /* remove the reference to the callback function */
    luaL_unref(to_info->L, LUA_REGISTRYINDEX, to_info->function_ref);

    /* remove the reference to the extra data argument */
    if (to_info->arg_ref != LUA_NOREF)
        luaL_unref(to_info->L, LUA_REGISTRYINDEX, to_info->arg_ref);

    g_free(to_info);
}

/* ---- end code adapted from lua-gnome-2008-12-01 src/glib/callback.c ---- */

ygtk_class_data y_g_class = {
    "GObject", "g", NULL, NULL
};

static int
yg_build_filename(lua_State *L)  /* -DOCNOTE- don't end the path component list with nil */
{
    int n, i;
    const char **filenames;
    gchar *result;

    n = lua_gettop(L);
    if (n < 1) {
        lua_pushnil(L);
        return 1;
    }
    filenames = (const char **)g_malloc0((n + 1)* sizeof(const char *));

    for (i = 1; i <= n; i++) {
        filenames[i - 1] = luaL_checkstring(L, i);
    }
    result = g_build_filenamev((char **)filenames);
    lua_pushstring(L, result);
    g_free(filenames);
    g_free(result);

    return 1;
}

static int
yg_file_test(lua_State *L)
{
    const char *filename = luaL_checkstring(L, 1);
    int test = luaL_checkint(L, 2);

    lua_pushboolean(L, g_file_test(filename, test));

    return 1;
}

static int
yg_get_current_time(lua_State *L)
{
    GTimeVal tv;
    lua_Number t;

    g_get_current_time(&tv);
    t = (lua_Number)tv.tv_sec + (lua_Number)tv.tv_usec / 1000000.0;
    lua_pushnumber(L, t);

    return 1;
}

/* -FIX- this is really closer to g_object_get() */
static int
yg_object_get_property(lua_State *L)  /* -DOCNOTE- accepts one or more property_names to get. */
{
    ygtk_object *o = ygtk_checkuserdata(L, 1);
    int n, p;

    n = lua_gettop(L) - 1;
    for (p = 0; p < n; p++) {
        const gchar *name = luaL_checkstring(L, p + 2);
        GParamSpec *spec = g_object_class_find_property(G_OBJECT_GET_CLASS(o->instance), name);
        GValue gvalue = { 0 };

        if (!spec)
            return luaL_error(L, "GObject %s has no property '%s'",
                              G_OBJECT_TYPE_NAME(o->instance), name);

        g_value_init(&gvalue, spec->value_type);
        g_object_get_property(G_OBJECT(o->instance), name, &gvalue);
        yg_gvalue_to_lua(L, &gvalue);
        g_value_unset(&gvalue);
    }

    return p;
}

/* -FIX- this is really closer to g_object_set() */
static int
yg_object_set_property(lua_State *L)  /* -DOCNOTE- accepts one or more pairs of (property_name, value). */
{
    ygtk_object *o = ygtk_checkuserdata(L, 1);
    int p;

    for (p = 2; p < lua_gettop(L); p += 2) {
        const gchar *name = luaL_checkstring(L, p);
        GParamSpec *spec = g_object_class_find_property(G_OBJECT_GET_CLASS(o->instance), name);
        GValue gvalue = { 0 };

        if (!spec)
            return luaL_error(L, "GObject %s has no property '%s'",
                              G_OBJECT_TYPE_NAME(o->instance), name);
        
        ygtk_lua_to_gvalue(L, p + 1, spec->value_type, &gvalue);
        g_object_set_property(G_OBJECT(o->instance), name, &gvalue);
        g_value_unset(&gvalue);
    }

    return 0;
}

// %% function:	signal_handler_block	voi
static int
yg_signal_handler_block (lua_State *L)
{
    g_signal_handler_block(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance,
        luaL_checkint(L, 2));
    return 0;
}

#line 979 "ygtk.c.in"
// %% function:	signal_handler_disconnect	voi
static int
yg_signal_handler_disconnect (lua_State *L)
{
    g_signal_handler_disconnect(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance,
        luaL_checkint(L, 2));
    return 0;
}

#line 980 "ygtk.c.in"
// %% function:	signal_handler_unblock	voi
static int
yg_signal_handler_unblock (lua_State *L)
{
    g_signal_handler_unblock(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance,
        luaL_checkint(L, 2));
    return 0;
}

#line 981 "ygtk.c.in"

static int
yg_source_remove(lua_State *L)
{
    guint tag = luaL_checkinteger(L, 1);
    y_gc_debug("source_remove called for %d\n", tag);
    lua_pushboolean(L, g_source_remove(tag));

    return 1;
}

// %% function:	usleep	vu
static int
yg_usleep (lua_State *L)
{
    g_usleep((unsigned long)luaL_checknumber(L, 1));
    return 0;
}

#line 993 "ygtk.c.in"

static const luaL_Reg ylib_g[] = {
    { "build_filename",            yg_build_filename },
    { "file_test",                 yg_file_test },
    { "get_current_time",          yg_get_current_time },
    { "idle_add",                  yg_idle_add },
    { "object_get_property",       yg_object_get_property },
    { "object_set_property",       yg_object_set_property },
    { "signal_connect",            yg_signal_connect },
    { "signal_connect_after",      yg_signal_connect_after },
    { "source_remove",             yg_source_remove },
    { "timeout_add",               yg_timeout_add },
// %% ylib def:	g
    { "signal_handler_block", yg_signal_handler_block },
    { "signal_handler_disconnect", yg_signal_handler_disconnect },
    { "signal_handler_unblock", yg_signal_handler_unblock },
    { "usleep",            yg_usleep },
#line 1006 "ygtk.c.in"
    { NULL, NULL }
};

// %% class:	nil	nil

static int
yg_boxed__gc(lua_State *L)
{
    GValue *gv = (GValue *) lua_touserdata(L, 1);
    y_gc_debug("yg_boxed__gc called on %s %p\n", g_type_name(gv->g_type), gv);
    g_value_unset(gv);

    return 0;
}

static int
yg_boxed__tostring(lua_State *L)
{
    GValue *gv = (GValue *) lua_touserdata(L, 1);
    gchar name[256];

    g_snprintf(name, 255, "GBoxed(%s): %p", g_type_name(gv->g_type), gv);
    lua_pushstring(L, name);

    return 1;
}

/* -FIX- -DOCNOTE- added function, ugly: returns button number, time, x, y */
static int
yg_boxed_get_button(lua_State *L)
{
    GValue *gv = (GValue *) lua_touserdata(L, 1);
    GdkEvent *event;

    if (gv->g_type != GDK_TYPE_EVENT) {
        fprintf(stderr, "g.boxed.get_button: object is not a GdkEvent!\n");
        lua_pushnil(L);
        return 1;
    }
    event = (GdkEvent *)g_value_get_boxed(gv);
    if (event->type != GDK_BUTTON_PRESS &&
        event->type != GDK_2BUTTON_PRESS &&
        event->type != GDK_3BUTTON_PRESS &&
        event->type != GDK_BUTTON_RELEASE) {
        fprintf(stderr, "g.boxed.get_button: GdkEvent is not a button press or release!\n");
        lua_pushnil(L);
        return 1;
    }

    lua_pushinteger(L, ((GdkEventButton *)event)->button);
    lua_pushinteger(L, ((GdkEventButton *)event)->time);
    lua_pushnumber(L,  ((GdkEventButton *)event)->x);
    lua_pushnumber(L,  ((GdkEventButton *)event)->y);

    return 4;
}

/* -FIX- -DOCNOTE- added function, ugly: returns type, time, state, keyval, hardware_keycode */
static int
yg_boxed_get_key(lua_State *L)
{
    GValue *gv = (GValue *) lua_touserdata(L, 1);
    GdkEvent *event;

    if (gv->g_type != GDK_TYPE_EVENT) {
        fprintf(stderr, "g.boxed.get_button: object is not a GdkEvent!\n");
        lua_pushnil(L);
        return 1;
    }
    event = (GdkEvent *)g_value_get_boxed(gv);
    if (event->type != GDK_KEY_PRESS &&
        event->type != GDK_KEY_RELEASE) {
        fprintf(stderr, "g.boxed.get_button: GdkEvent is not a key press or release!\n");
        lua_pushnil(L);
        return 1;
    }

    lua_pushinteger(L, ((GdkEventKey *)event)->type);
    lua_pushinteger(L, ((GdkEventKey *)event)->time);
    lua_pushinteger(L, ((GdkEventKey *)event)->state);
    lua_pushinteger(L, ((GdkEventKey *)event)->keyval);
    lua_pushinteger(L, ((GdkEventKey *)event)->hardware_keycode);

    return 5;
}

static const luaL_Reg ylib_g_boxed[] = {
    { "__gc",       yg_boxed__gc },
    { "__tostring", yg_boxed__tostring },
    { "get_button", yg_boxed_get_button },
    { "get_key",    yg_boxed_get_key },
    { NULL, NULL }
};

#line 1172 "ygtk.c.in"

/* ==== cairo ==== */

// %% class:	cairo_context	cairo

static const luaL_Reg ylib_cairo[] = {
    { NULL, NULL }
};

static int
ycairo_context__gc(lua_State *L)
{
    ygtk_object *o = (ygtk_object *)lua_touserdata(L, 1);

    if (o->instance) {
        y_gc_debug("ycairo_context__gc called on %p -> %p\n", o, o->instance);
        cairo_destroy((cairo_t *)(o->instance));
        o->instance = NULL;
} else { y_gc_debug("ycairo_context__gc: %p already nulled\n", o);
    }

    return 0;
}

static int
ycairo_context__tostring(lua_State *L)
{
    ygtk_object *o = (ygtk_object*) lua_touserdata(L, 1);
    gchar name[256];

    g_snprintf(name, 255, "cairo context: %p -> %p", o, o->instance);
    lua_pushstring(L, name);

    return 1;
}

// %% function:	arc	voddddd
static int
ycairo_context_arc (lua_State *L)
{
    cairo_arc(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance,
        luaL_checknumber(L, 2),
        luaL_checknumber(L, 3),
        luaL_checknumber(L, 4),
        luaL_checknumber(L, 5),
        luaL_checknumber(L, 6));
    return 0;
}

#line 1208 "ygtk.c.in"

#line 1219 "ygtk.c.in"

// %% function:	close_path	vo
static int
ycairo_context_close_path (lua_State *L)
{
    cairo_close_path(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance);
    return 0;
}

#line 1220 "ygtk.c.in"

static int
ycairo_context_create(lua_State *L)
{
    ygtk_object *s = ygtk_checkuserdata(L, 1);

    cairo_t *cr = cairo_create((cairo_surface_t *)s->instance); /* may fail, but cr will point to error context */
    ygtk_make_simple_object(L, cr, "cairo.context");

    return 1;
}

// %% function:	curve_to	vodddddd
static int
ycairo_context_curve_to (lua_State *L)
{
    cairo_curve_to(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance,
        luaL_checknumber(L, 2),
        luaL_checknumber(L, 3),
        luaL_checknumber(L, 4),
        luaL_checknumber(L, 5),
        luaL_checknumber(L, 6),
        luaL_checknumber(L, 7));
    return 0;
}

#line 1233 "ygtk.c.in"
// %% function:	fill	vo
static int
ycairo_context_fill (lua_State *L)
{
    cairo_fill(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance);
    return 0;
}

#line 1234 "ygtk.c.in"
// %% function:	fill_preserve	vo
static int
ycairo_context_fill_preserve (lua_State *L)
{
    cairo_fill_preserve(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance);
    return 0;
}

#line 1235 "ygtk.c.in"
// %% function:	line_to	vodd
static int
ycairo_context_line_to (lua_State *L)
{
    cairo_line_to(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance,
        luaL_checknumber(L, 2),
        luaL_checknumber(L, 3));
    return 0;
}

#line 1236 "ygtk.c.in"
// %% function:	move_to	vodd
static int
ycairo_context_move_to (lua_State *L)
{
    cairo_move_to(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance,
        luaL_checknumber(L, 2),
        luaL_checknumber(L, 3));
    return 0;
}

#line 1237 "ygtk.c.in"
// %% function:	paint	vo
static int
ycairo_context_paint (lua_State *L)
{
    cairo_paint(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance);
    return 0;
}

#line 1238 "ygtk.c.in"

#line 1250 "ygtk.c.in"

// %% function:	rectangle	vodddd
static int
ycairo_context_rectangle (lua_State *L)
{
    cairo_rectangle(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance,
        luaL_checknumber(L, 2),
        luaL_checknumber(L, 3),
        luaL_checknumber(L, 4),
        luaL_checknumber(L, 5));
    return 0;
}

#line 1251 "ygtk.c.in"
// %% function:	rel_line_to	vodd
static int
ycairo_context_rel_line_to (lua_State *L)
{
    cairo_rel_line_to(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance,
        luaL_checknumber(L, 2),
        luaL_checknumber(L, 3));
    return 0;
}

#line 1252 "ygtk.c.in"
// %% function:	restore	vo
static int
ycairo_context_restore (lua_State *L)
{
    cairo_restore(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance);
    return 0;
}

#line 1253 "ygtk.c.in"

#line 1265 "ygtk.c.in"

// %% function:	save	vo
static int
ycairo_context_save (lua_State *L)
{
    cairo_save(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance);
    return 0;
}

#line 1266 "ygtk.c.in"
// %% function:	scale	vodd
static int
ycairo_context_scale (lua_State *L)
{
    cairo_scale(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance,
        luaL_checknumber(L, 2),
        luaL_checknumber(L, 3));
    return 0;
}

#line 1267 "ygtk.c.in"
// %% function:	select_font_face	vosii
static int
ycairo_context_select_font_face (lua_State *L)
{
    cairo_select_font_face(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance,
        (const char *)luaL_checkstring(L, 2),
        luaL_checkint(L, 3),
        luaL_checkint(L, 4));
    return 0;
}

#line 1268 "ygtk.c.in"

#line 1280 "ygtk.c.in"

// %% function:	set_font_size	vod
static int
ycairo_context_set_font_size (lua_State *L)
{
    cairo_set_font_size(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance,
        luaL_checknumber(L, 2));
    return 0;
}

#line 1281 "ygtk.c.in"
// %% function:	set_line_cap	voi
static int
ycairo_context_set_line_cap (lua_State *L)
{
    cairo_set_line_cap(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance,
        luaL_checkint(L, 2));
    return 0;
}

#line 1282 "ygtk.c.in"
// %% function:	set_line_width	vod
static int
ycairo_context_set_line_width (lua_State *L)
{
    cairo_set_line_width(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance,
        luaL_checknumber(L, 2));
    return 0;
}

#line 1283 "ygtk.c.in"

static int
ycairo_context_set_source_hsv(lua_State *L)  /* -DOCNOTE- an addition to the cario API */
{
    ygtk_object *cr = ygtk_checkuserdata(L, 1);
    double h = luaL_checknumber(L, 2);
    double s = luaL_checknumber(L, 3);
    double v = luaL_checknumber(L, 4);
    double f, p, q, t;
    int i;

    if (s == 0.0) {
        cairo_set_source_rgb(cr->instance, v, v, v);
        return 0;
    }
    h *= 6.0;
    if (h == 6.0) h = 0.0;
    i = (int)floor(h);
    f = h - (double)i;
    p = v * (1.0 - s);
    q = v * (1.0 - s * f);
    t = v * (1.0 - s * (1.0 - f));

    switch (i) {
      case 0:
        cairo_set_source_rgb(cr->instance, v, t, p);
        break;
      case 1:
        cairo_set_source_rgb(cr->instance, q, v, p);
        break;
      case 2:
        cairo_set_source_rgb(cr->instance, p, v, t);
        break;
      case 3:
        cairo_set_source_rgb(cr->instance, p, q, v);
        break;
      case 4:
        cairo_set_source_rgb(cr->instance, t, p, v);
        break;
      default:  /* 5 */
        cairo_set_source_rgb(cr->instance, v, p, q);
        break;
    }

    return 0;
}

// %% function:	set_source_rgb	voddd
static int
ycairo_context_set_source_rgb (lua_State *L)
{
    cairo_set_source_rgb(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance,
        luaL_checknumber(L, 2),
        luaL_checknumber(L, 3),
        luaL_checknumber(L, 4));
    return 0;
}

#line 1331 "ygtk.c.in"

#line 1346 "ygtk.c.in"

// %% function:	set_source_surface	voodd
static int
ycairo_context_set_source_surface (lua_State *L)
{
    cairo_set_source_surface(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance,
        ((ygtk_object *)ygtk_checkuserdata(L, 2))->instance,
        luaL_checknumber(L, 3),
        luaL_checknumber(L, 4));
    return 0;
}

#line 1347 "ygtk.c.in"

#line 1358 "ygtk.c.in"

// %% function:	show_text	vos
static int
ycairo_context_show_text (lua_State *L)
{
    cairo_show_text(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance,
        (const char *)luaL_checkstring(L, 2));
    return 0;
}

#line 1359 "ygtk.c.in"
// %% function:	stroke	vo
static int
ycairo_context_stroke (lua_State *L)
{
    cairo_stroke(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance);
    return 0;
}

#line 1360 "ygtk.c.in"

#line 1372 "ygtk.c.in"

// %% function:	translate	vodd
static int
ycairo_context_translate (lua_State *L)
{
    cairo_translate(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance,
        luaL_checknumber(L, 2),
        luaL_checknumber(L, 3));
    return 0;
}

#line 1373 "ygtk.c.in"
#line 1376 "ygtk.c.in"

static const luaL_Reg ylib_cairo_context[] = {
    { "__gc",             ycairo_context__gc },
    { "__tostring",       ycairo_context__tostring },
#line 1381 "ygtk.c.in"
    { "create",           ycairo_context_create },
#line 1383 "ygtk.c.in"
    { "destroy",          ycairo_context__gc },
#line 1387 "ygtk.c.in"
    { "set_source_hsv",   ycairo_context_set_source_hsv },
#line 1391 "ygtk.c.in"
// %% ylib def:	cairo_context
    { "arc",               ycairo_context_arc },
    { "close_path",        ycairo_context_close_path },
    { "curve_to",          ycairo_context_curve_to },
    { "fill",              ycairo_context_fill },
    { "fill_preserve",     ycairo_context_fill_preserve },
    { "line_to",           ycairo_context_line_to },
    { "move_to",           ycairo_context_move_to },
    { "paint",             ycairo_context_paint },
    { "rectangle",         ycairo_context_rectangle },
    { "rel_line_to",       ycairo_context_rel_line_to },
    { "restore",           ycairo_context_restore },
    { "save",              ycairo_context_save },
    { "scale",             ycairo_context_scale },
    { "select_font_face",  ycairo_context_select_font_face },
    { "set_font_size",     ycairo_context_set_font_size },
    { "set_line_cap",      ycairo_context_set_line_cap },
    { "set_line_width",    ycairo_context_set_line_width },
    { "set_source_rgb",    ycairo_context_set_source_rgb },
    { "set_source_surface", ycairo_context_set_source_surface },
    { "show_text",         ycairo_context_show_text },
    { "stroke",            ycairo_context_stroke },
    { "translate",         ycairo_context_translate },
#line 1391 "ygtk.c.in"
    { NULL, NULL }
};

// %% class:	nil	nil

static int
ycairo_surface__gc(lua_State *L)
{
    ygtk_object *o = (ygtk_object *)lua_touserdata(L, 1);

    if (o->instance) {
        y_gc_debug("ycairo_surface__gc called on %p -> %p\n", o, o->instance);
        cairo_surface_destroy((cairo_surface_t *)(o->instance));
        o->instance = NULL;
} else { y_gc_debug("ycairo_surface__gc: %p already nulled\n", o);
    }

    return 0;
}

static int
ycairo_surface__tostring(lua_State *L)
{
    ygtk_object *o = (ygtk_object*) lua_touserdata(L, 1);
    gchar name[256];

    g_snprintf(name, 255, "cairo surface: %p -> %p", o, o->instance);
    lua_pushstring(L, name);

    return 1;
}

#line 1467 "ygtk.c.in"

static int
ycairo_image_surface_create(lua_State *L)
{
    int format = luaL_checkint(L, 1);
    int width  = luaL_checkint(L, 2);
    int height = luaL_checkint(L, 3);
    cairo_surface_t *s;

    s = cairo_image_surface_create(format, width, height); /* may fail, but s will point to "nil" surface */
    ygtk_make_simple_object(L, s, "cairo.surface");

    return 1;
}

#line 1539 "ygtk.c.in"

static const luaL_Reg ylib_cairo_surface[] = {
    { "__gc",                 ycairo_surface__gc },
    { "__tostring",           ycairo_surface__tostring },
    { "destroy",              ycairo_surface__gc },
#line 1547 "ygtk.c.in"
    { NULL, NULL }
};

/* -DOCNOTE- syntactic sugar for the cairo image surface methods (since they don't inherit) */
static const luaL_Reg ylib_cairo_image_surface[] = {
    /* cairo_surface_t methods */
    { "__gc",                 ycairo_surface__gc },
    { "__tostring",           ycairo_surface__tostring },
    { "destroy",              ycairo_surface__gc },
#line 1557 "ygtk.c.in"
    /* cairo_image_surface_t methods */
    { "create",               ycairo_image_surface_create },
#line 1562 "ygtk.c.in"
    { NULL, NULL }
};

#line 1577 "ygtk.c.in"
/* ==== pango ==== */

static const luaL_Reg ylib_pango[] = {
#line 1581 "ygtk.c.in"
    { NULL, NULL }
};

/* ==== gdk/gtk class support ==== */

ygtk_object *
ygtk_make_object(lua_State *L, GObject *o, ygtk_class_data *class)
{
    ygtk_object *u;
    GType type;

    u = lua_newuserdata(L, sizeof(ygtk_object));  /* -- userdata */
    u->instance = (gpointer)o;

    if (class) {
        /* make sure the GType of this object has a qdata pointing to our class structure */
        if (g_type_get_qdata(G_OBJECT_TYPE(o), ygtk_class_pointer_quark) == NULL) {
            type = g_type_from_name(class->class);
            g_type_set_qdata(type, ygtk_class_pointer_quark, class);
        }
    } else {
        /* try to look up our class struct from the GType of this object */
        class = g_type_get_qdata(G_OBJECT_TYPE(o), ygtk_class_pointer_quark);
        if (class == NULL) {
            luaL_error(L, "ygtk_make_object called without class data on previously "
                          "unseen class '%s'", G_OBJECT_TYPE_NAME(o));
        }
    }

    lua_getglobal(L, class->lib);             /* -- userdata lib */
    lua_getfield(L, -1, class->table);        /* -- userdata lib class_table */
    lua_remove(L, -2);                        /* -- userdata class_table */
    lua_setmetatable(L, -2);                  /* -- userdata */

    return u;
}

/* ygtk__index()
 *
 * Perform '__index' for a ygtk object. Search down the inheritance list provided
 * in the upvalue, assuming that all lib and table entries exist.  Basically, this
 * tries to be a faster version of e.g.:
 *
 *   gtk.about_dialog.__index = function(t, k)
 *     return gtk.about_dialog[k] or gtk.dialog[k] or gtk.window[k] or 
 *            gtk.bin[k] or gtk.container[k] or gtk.widget[k] or g[k]
 *   end
 *
 * while not failing for 'false' values.
 */
static int
ygtk__index(lua_State *L)
{
    ygtk_class_data *c = lua_touserdata(L, lua_upvalueindex(1));
    const char *lib_on_stack = NULL;

    lua_remove(L, -2);                    /* object key -- key */

    while (c) {
        if (!lib_on_stack) {
            lua_getglobal(L, c->lib);     /* -- key lib */
            lib_on_stack = c->lib;
            if (!lua_istable(L, -1))
                goto liberror;
        } else if (strcmp(lib_on_stack, c->lib)) {
            lua_pop(L, 1);
            lua_getglobal(L, c->lib);     /* -- key lib */
            lib_on_stack = c->lib;
            if (!lua_istable(L, -1))
                goto liberror;
        }

        if (c->table) {  /* try lib[table] */
            lua_pushstring(L, c->table);  /* -- key lib "table" */
            lua_rawget(L, -2);            /* -- key lib lib[table] */
            if (!lua_istable(L, -1))
                goto tableerror;
            lua_pushvalue(L, -3);         /* -- key lib lib[table] key */
            lua_rawget(L, -2);            /* -- key lib lib[table] (result) */
            if (!lua_isnil(L, -1)) {
                lua_replace(L, -4);       /* -- result lib lib[table] */
                lua_pop(L, 2);
                return 1;                 /* -- result */
            }
            lua_pop(L, 2);                /* -- key lib */
        } else {  /* just search lib */
            lua_pushvalue(L, -2);         /* -- key lib key */
            lua_rawget(L, -2);            /* -- key lib (result) */
            if (!lua_isnil(L, -1)) {
                lua_replace(L, -3);       /* -- result lib */
                lua_pop(L, 1);            /* -- result */
                return 1;
            }
            lua_pop(L, 1);                /* -- key lib */
        }

        c = c->parent;                    /* -- key oldlib */
    }

    /* not found */
    lua_pop(L, 2);
    lua_pushnil(L);  /* -- nil */
    return 1;

  liberror:
    return luaL_error(L, "ygtk error: '%s' is no longer a table", c->lib);
  tableerror:
    return luaL_error(L, "ygtk error: '%s.%s' is no longer a table", c->lib, c->table);
}

static int
ygtk__gc(lua_State *L)
{
    ygtk_object *o = (ygtk_object*) lua_touserdata(L, 1);
    y_gc_debug("ygtk__gc called on %s %p\n", g_type_name(G_TYPE_FROM_INSTANCE(o->instance)), o->instance);
    g_object_unref(o->instance);
    
    return 0;
}

static int
ygtk__tostring(lua_State *L)
{
    ygtk_object *o = (ygtk_object*) lua_touserdata(L, 1);
    gchar name[256];

    g_snprintf(name, 255, "%s: %p (%p)", g_type_name(G_TYPE_FROM_INSTANCE(o->instance)), o, o->instance);
    lua_pushstring(L, name);

    return 1;
}

static void
ygtk_build_class(lua_State *L,
                 ygtk_class_data *class,
                 const luaL_Reg *methods)
{
    /* push class table, creating it if needed */
    lua_getglobal(L, class->lib);
    if (lua_isnil(L, -1)) {
        luaL_error(L, "can't find ygtk library table '%s'", class->lib);
    }
    lua_getfield(L, -1, class->table);        /* -- lib (classtable | nil) */
    if (lua_isnil(L, -1)) {
        lua_pop(L, 1);                        /* -- lib */
        lua_newtable(L);                      /* -- lib classtable */
        lua_pushstring(L, class->table);      /* -- lib classtable "table" */
        lua_pushvalue(L, -2);                 /* -- lib classtable "table" classtable */
        lua_settable(L, -4);                  /* -- lib classtable */
    }
    lua_remove(L, -2);                        /* -- classtable */

    /* 'classtable.__index = ygtk__index' with inheritance list as closure upvalue */
    lua_pushliteral(L, "__index");            /* -- classtable "__index" */
    lua_pushlightuserdata(L, class);          /* -- classtable "__index" class-data-lud */
    lua_pushcclosure(L, ygtk__index, 1);      /* -- classtable "__index" ygtk__index-closure */
    lua_rawset(L, -3);                        /* -- classtable */

    /* 'classtable.__gc = ygtk__gc' */
    lua_pushliteral(L, "__gc");               /* -- classtable "__gc" */
    lua_pushcfunction(L, ygtk__gc);           /* -- classtable "__gc" ygtk__gc-function */
    lua_rawset(L, -3);                        /* -- classtable */

    /* 'classtable.__tostring = ygtk__tostring' */
    lua_pushliteral(L, "__tostring");         /* -- classtable "__tostring" */
    lua_pushcfunction(L, ygtk__tostring);     /* -- classtable "__tostring" ygtk__tostring-function */
    lua_rawset(L, -3);                        /* -- classtable */

    /* now register the class functions */
    ygtk_setfuncs0(L, methods);               /* -- classtable */
    lua_remove(L, -1);                        /* -- */
}

/* ==== gdk ==== */

// %% class:	gdk	gdk

static int
ygdk_cairo_create(lua_State *L)
{
    ygtk_object *drawable;
    cairo_t *cr;

    luaL_checktype(L, 1, LUA_TUSERDATA);

    drawable = lua_touserdata(L, 1);
    cr = gdk_cairo_create(GDK_DRAWABLE(drawable->instance));

    ygtk_make_simple_object(L, cr, "cairo.context");
    
    return 1;
}

// %% function:	cairo_set_source_pixbuf	voo(GDK_PIXBUF)dd
static int
ygdk_cairo_set_source_pixbuf (lua_State *L)
{
    gdk_cairo_set_source_pixbuf(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance,
        GDK_PIXBUF(((ygtk_object *)ygtk_checkuserdata(L, 2))->instance),
        luaL_checknumber(L, 3),
        luaL_checknumber(L, 4));
    return 0;
}

#line 1774 "ygtk.c.in"

static const luaL_Reg ylib_gdk[] = {
    { "cairo_create", ygdk_cairo_create },
// %% ylib def:	gdk
    { "cairo_set_source_pixbuf", ygdk_cairo_set_source_pixbuf },
#line 1778 "ygtk.c.in"
    { NULL, NULL }
};

/* GObject / GdkDrawable */

ygtk_class_data y_gdk_drawable_class = {
    "GdkDrawable", "gdk", "drawable", &y_g_class
};

static int
ygdk_drawable_get_size(lua_State *L)
{
    ygtk_object *drawable = ygtk_checkuserdata(L, 1);
    gint width, height;

    gdk_drawable_get_size(GDK_DRAWABLE(drawable->instance), &width, &height);
    lua_pushinteger(L, width);
    lua_pushinteger(L, height);

    return 2;
}

static const luaL_Reg ylib_gdk_drawable[] = {
    { "get_size",        ygdk_drawable_get_size },
    { NULL, NULL }
};

/* GObject / GdkDrawable / GdkWindow */

ygtk_class_data y_gdk_window_class = {
    "GdkWindow", "gdk", "window", &y_gdk_drawable_class
};

#if GTK_CHECK_VERSION(2, 22, 0)
static int
ygdk_window_create_similar_surface(lua_State *L)
{
    ygtk_object *w = ygtk_checkuserdata(L, 1);
    int content = luaL_checkint(L, 2);
    int width  = luaL_checkint(L, 3);
    int height = luaL_checkint(L, 4);
    cairo_surface_t *s;

    s = gdk_window_create_similar_surface(w->instance, content, width, height); /* may fail, but s will point to "nil" surface */
    ygtk_make_simple_object(L, s, "cairo.surface");

    return 1;
}
#endif

static const luaL_Reg ylib_gdk_window[] = {
    /* the gdk.window class is needed because gtk_widget_get_window() returns GdkWindow */
#if GTK_CHECK_VERSION(2, 22, 0)
    { "create_similar_surface", ygdk_window_create_similar_surface },
#endif
    { NULL, NULL }
};

/* GObject / GdkPixbuf */

ygtk_class_data y_gdk_pixbuf_class = {
    "GdkPixbuf", "gdk", "pixbuf", &y_g_class
};

static int
ygdk_pixbuf_new_from_file(lua_State *L)
{
    const gchar *filename = luaL_checkstring(L, 1);
    GdkPixbuf *pixbuf;
    GError *error = NULL;

    pixbuf = gdk_pixbuf_new_from_file(filename, &error);
    if (pixbuf) {
        /* we hold a (non-floating) reference */
        ygtk_make_object(L, G_OBJECT(pixbuf), &y_gdk_pixbuf_class);

        return 1;
    } else {
        lua_pushnil(L);
        lua_pushstring(L, error->message);
        g_error_free(error);

        return 2;
    }
}

static int
ygdk_pixbuf_new_subpixbuf(lua_State *L)
{
    ygtk_object *p = ygtk_checkuserdata(L, 1);
    GdkPixbuf *pixbuf = gdk_pixbuf_new_subpixbuf(GDK_PIXBUF(p->instance),
                                                 luaL_checkinteger(L, 2),
                                                 luaL_checkinteger(L, 3),
                                                 luaL_checkinteger(L, 4),
                                                 luaL_checkinteger(L, 5));

    /* we hold a (non-floating) reference */
    ygtk_make_object(L, G_OBJECT(pixbuf), &y_gdk_pixbuf_class);

    return 1;
}

#line 1893 "ygtk.c.in"

static const luaL_Reg ylib_gdk_pixbuf[] = {
    { "new_from_file", ygdk_pixbuf_new_from_file },
    { "new_subpixbuf", ygdk_pixbuf_new_subpixbuf },
#line 1898 "ygtk.c.in"
    { NULL, NULL }
};

/* ==== Gtk interfaces (may have entries in each object table that implements them) ==== */

#line 2179 "ygtk.c.in"

/* ==== Gtk non-object functions ==== */

static int
ygtk_events_pending(lua_State *L)
{
    lua_pushboolean(L, gtk_events_pending());

    return 1;
}

static int
ygtk_init(lua_State *L)
{
    int argc = 1;
    char *argv_[2] = { "[ygtk]", 0 };
    char **argv = &argv_[0];

    gtk_set_locale();
    gtk_init(&argc, &argv);

    return 0;
}

static int
ygtk_main(lua_State* L)
{
    gtk_main();

    return 0;
}

static int
ygtk_main_iteration_do(lua_State* L)
{
    luaL_checktype(L, 1, LUA_TBOOLEAN);

    lua_pushboolean(L, gtk_main_iteration_do(lua_toboolean(L, 1)));

    return 1;
}

static int
ygtk_main_quit(lua_State* L)
{
    gtk_main_quit();

    return 0;
}

#line 2250 "ygtk.c.in"

static int ygtk_text_iter_get_offset(lua_State *L);  /* forward */
static int ygtk_text_iter_new(lua_State *L);         /* forward */

static const luaL_Reg ylib_gtk[] = {
    { "events_pending",    ygtk_events_pending },
    { "init",              ygtk_init },
    { "main",              ygtk_main },
    { "main_iteration_do", ygtk_main_iteration_do },
    { "main_quit",         ygtk_main_quit },
    { "text_iter_get_offset", ygtk_text_iter_get_offset },
    { "text_iter_new",     ygtk_text_iter_new },
#line 2265 "ygtk.c.in"
    { NULL, NULL }
};

#line 2522 "ygtk.c.in"

/* GObject / GtkTextBuffer */

static int
ygtk_text_iter_get_offset(lua_State *L)
{
    /* no type information, so no type checking -- be careful! */
    lua_pushinteger(L, gtk_text_iter_get_offset((GtkTextIter *)ygtk_checkuserdata(L, 1)));

    return 1;
}

static int
ygtk_text_iter_new(lua_State *L)
{
    /* no type information, so no type checking -- be careful! */
    lua_newuserdata(L, sizeof(GtkTextIter));

    return 1;
}

ygtk_class_data y_gtk_text_buffer_class = {
    "GtkTextBuffer", "gtk", "text_buffer", &y_g_class
};

// %% function:	apply_tag_by_name	vo(GTK_TEXT_BUFFER)spp
static int
ygtk_text_buffer_apply_tag_by_name (lua_State *L)
{
    gtk_text_buffer_apply_tag_by_name(GTK_TEXT_BUFFER(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance),
        (const char *)luaL_checkstring(L, 2),
        ygtk_checkuserdata(L, 3),
        ygtk_checkuserdata(L, 4));
    return 0;
}

#line 2547 "ygtk.c.in"

/* -DOCNOTE- GtkTextBuffer:create_mark does not return the mark */
// %% function:	create_mark	vo(GTK_TEXT_BUFFER)spb
static int
ygtk_text_buffer_create_mark (lua_State *L)
{
    gtk_text_buffer_create_mark(GTK_TEXT_BUFFER(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance),
        (const char *)luaL_checkstring(L, 2),
        ygtk_checkuserdata(L, 3),
        lua_toboolean(L, 4));
    return 0;
}

#line 2550 "ygtk.c.in"

static int
ygtk_text_buffer_create_tag(lua_State *L)  /* -DOCNOTE- accepts one or more pairs of (property_name, value). */
                                           /* -DOCNOTE- returns void */
{
    ygtk_object *b = ygtk_checkuserdata(L, 1);
    const gchar *tag_name = lua_isnil(L, 2) ? NULL : luaL_checkstring(L, 2);
    GtkTextTag *tag;
    int p;

    /* Ack. GTK+'s language binding sucks. Can't pass a variable number of name/value pairs to
     * gtk_text_buffer_create_tag(), so we create the tag manually, set properties, then add
     * it to the buffer. */
    tag = gtk_text_tag_new(tag_name);
    /* we hold a non-floating ref */
    for (p = 3; p < lua_gettop(L); p += 2) {
        const gchar *name = luaL_checkstring(L, p);
        GParamSpec *spec = g_object_class_find_property(G_OBJECT_GET_CLASS(tag), name);
        GValue gvalue = { 0 };

        if (!spec)
            return luaL_error(L, "GtkTextTag has no property '%s'", name);

        ygtk_lua_to_gvalue(L, p + 1, spec->value_type, &gvalue);
        g_object_set_property(G_OBJECT(tag), name, &gvalue);
        g_value_unset(&gvalue);
    }
    gtk_text_tag_table_add(gtk_text_buffer_get_tag_table(GTK_TEXT_BUFFER(b->instance)), tag);

    /* rather than adding proper support for GtkTextTags, and returning one here, we just
     * drop our ref and return nothing. */
    g_object_unref(tag);

    return 0;
}

// %% function:	get_iter_at_offset	vo(GTK_TEXT_BUFFER)pi
static int
ygtk_text_buffer_get_iter_at_offset (lua_State *L)
{
    gtk_text_buffer_get_iter_at_offset(GTK_TEXT_BUFFER(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance),
        ygtk_checkuserdata(L, 2),
        luaL_checkint(L, 3));
    return 0;
}

#line 2587 "ygtk.c.in"

static int
ygtk_text_buffer_insert(lua_State *L)
{
    ygtk_object *tb = ygtk_checkuserdata(L, 1);
    GtkTextIter *ti = ygtk_checkuserdata(L, 2);
    size_t len;
    const gchar *text = luaL_checklstring(L, 3, &len);

    /* -DOCNOTE-
     * if fourth argument 'len' is not given: use Lua string length
     * if it is given and is -1: use Lua string length
     * it if is given and is not -1: use given string length
     */
    if (!lua_isnone(L, 4)) {
        int tmp = luaL_checknumber(L, 4);

        if (tmp != -1)
            len = tmp;
    }
    gtk_text_buffer_insert(GTK_TEXT_BUFFER(tb->instance), ti, text, len);

    return 0;
}

// %% function:	insert_pixbuf	vo(GTK_TEXT_BUFFER)po(GDK_PIXBUF)
static int
ygtk_text_buffer_insert_pixbuf (lua_State *L)
{
    gtk_text_buffer_insert_pixbuf(GTK_TEXT_BUFFER(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance),
        ygtk_checkuserdata(L, 2),
        GDK_PIXBUF(((ygtk_object *)ygtk_checkuserdata(L, 3))->instance));
    return 0;
}

#line 2613 "ygtk.c.in"

static int
ygtk_text_buffer_insert_with_tags_by_name(lua_State *L)
{
    ygtk_object *tb = ygtk_checkuserdata(L, 1);
    GtkTextIter *ti = ygtk_checkuserdata(L, 2);
    const gchar *text = luaL_checkstring(L, 3);
    gint len = luaL_checkinteger(L, 4);
    int p;
    const gchar *name[8];

    if (lua_gettop(L) > 12) {
        fprintf(stderr, "ERROR: ygtk_text_buffer_insert_with_tags_by_name does not support more than eight tag names\n"); /* -DOCNOTE- */
    }
    for (p = 5; p <= 12; p++) {
        if (p <= lua_gettop(L))
            name[p - 5] = luaL_checkstring(L, p);
        else
            name[p - 5] = NULL;
    }
    gtk_text_buffer_insert_with_tags_by_name(GTK_TEXT_BUFFER(tb->instance), ti, text, len,
                                             name[0], name[1], name[2], name[3],
                                             name[4], name[5], name[6], name[7], NULL);

    return 0;
}

#line 2659 "ygtk.c.in"

static int
ygtk_text_buffer_set_text(lua_State *L)
{
    ygtk_object *b = ygtk_checkuserdata(L, 1);
    size_t len;
    const gchar *text = luaL_checklstring(L, 2, &len);

    /* -DOCNOTE-
     * if third argument 'length' is not given: use Lua string length
     * if it is given and is -1: use Lua string length
     * it if is given and is not -1: use given string length
     */
    if (!lua_isnone(L, 3)) {
        int tmp = luaL_checknumber(L, 3);

        if (tmp != -1)
            len = tmp;
    }
    gtk_text_buffer_set_text(GTK_TEXT_BUFFER(b->instance), text, len);

    return 0;
}

static const luaL_Reg ylib_gtk_text_buffer[] = {
    { "create_tag",    ygtk_text_buffer_create_tag },
    { "insert",        ygtk_text_buffer_insert },
    { "insert_with_tags_by_name", ygtk_text_buffer_insert_with_tags_by_name },
#line 2688 "ygtk.c.in"
    { "set_text",      ygtk_text_buffer_set_text },
// %% ylib def:	gtk_text_buffer
    { "apply_tag_by_name", ygtk_text_buffer_apply_tag_by_name },
    { "create_mark",       ygtk_text_buffer_create_mark },
    { "get_iter_at_offset", ygtk_text_buffer_get_iter_at_offset },
    { "insert_pixbuf",     ygtk_text_buffer_insert_pixbuf },
#line 2689 "ygtk.c.in"
    { NULL, NULL }
};

#line 2860 "ygtk.c.in"

/* GtkObject / GtkAdjustment */

ygtk_class_data y_gtk_adjustment_class = {
    "GtkAdjustment", "gtk", "adjustment", &y_g_class
};

// %% function:	get_lower	do(GTK_ADJUSTMENT)
static int
ygtk_adjustment_get_lower (lua_State *L)
{
    double d;

    d = gtk_adjustment_get_lower(GTK_ADJUSTMENT(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance));
    lua_pushnumber(L, d);
    return 1;
}

#line 2867 "ygtk.c.in"
// %% function:	get_upper	do(GTK_ADJUSTMENT)
static int
ygtk_adjustment_get_upper (lua_State *L)
{
    double d;

    d = gtk_adjustment_get_upper(GTK_ADJUSTMENT(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance));
    lua_pushnumber(L, d);
    return 1;
}

#line 2868 "ygtk.c.in"
// %% function:	get_value	do(GTK_ADJUSTMENT)
static int
ygtk_adjustment_get_value (lua_State *L)
{
    double d;

    d = gtk_adjustment_get_value(GTK_ADJUSTMENT(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance));
    lua_pushnumber(L, d);
    return 1;
}

#line 2869 "ygtk.c.in"
// %% function:	new	Odddddd
static int
ygtk_adjustment_new (lua_State *L)
{
    GObject *o;

    o = (GObject *)gtk_adjustment_new(luaL_checknumber(L, 1),
            luaL_checknumber(L, 2),
            luaL_checknumber(L, 3),
            luaL_checknumber(L, 4),
            luaL_checknumber(L, 5),
            luaL_checknumber(L, 6));
    g_object_ref_sink(o);
    ygtk_make_object(L, o, &y_gtk_adjustment_class);

    return 1;
}

#line 2870 "ygtk.c.in"
// %% function:	set_value	vo(GTK_ADJUSTMENT)d
static int
ygtk_adjustment_set_value (lua_State *L)
{
    gtk_adjustment_set_value(GTK_ADJUSTMENT(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance),
        luaL_checknumber(L, 2));
    return 0;
}

#line 2871 "ygtk.c.in"

static const luaL_Reg ylib_gtk_adjustment[] = {
// %% ylib def:	gtk_adjustment
    { "get_lower",         ygtk_adjustment_get_lower },
    { "get_upper",         ygtk_adjustment_get_upper },
    { "get_value",         ygtk_adjustment_get_value },
    { "new",               ygtk_adjustment_new },
    { "set_value",         ygtk_adjustment_set_value },
#line 2874 "ygtk.c.in"
    { NULL, NULL }
};

#line 2991 "ygtk.c.in"

/* GtkObject / GtkWidget */

ygtk_class_data y_gtk_widget_class = {
    "GtkWidget", "gtk", "widget", &y_g_class
};

#line 3007 "ygtk.c.in"

static int
ygtk_widget_SET_FLAGS(lua_State *L)
{
    ygtk_object *w = ygtk_checkuserdata(L, 1);
    GtkWidgetFlags flags = luaL_checkinteger(L, 2);

    GTK_WIDGET_SET_FLAGS(GTK_WIDGET(w->instance), flags);

    return 0;
}

#line 3056 "ygtk.c.in"

// %% function:	add_events	vo(GTK_WIDGET)i
static int
ygtk_widget_add_events (lua_State *L)
{
    gtk_widget_add_events(GTK_WIDGET(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance),
        luaL_checkint(L, 2));
    return 0;
}

#line 3057 "ygtk.c.in"
#line 3068 "ygtk.c.in"

// %% function:	destroy	vo(GTK_WIDGET)
static int
ygtk_widget_destroy (lua_State *L)
{
    gtk_widget_destroy(GTK_WIDGET(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance));
    return 0;
}

#line 3069 "ygtk.c.in"

static int
ygtk_widget_get_window(lua_State *L)
{
    ygtk_object *w;
    GdkWindow *window;
    
    luaL_checktype(L, 1, LUA_TUSERDATA);
    
    w = lua_touserdata(L, 1);
    window = gtk_widget_get_window(GTK_WIDGET(w->instance));
    if (window) {
        g_object_ref(window);
        ygtk_make_object(L, G_OBJECT(window), &y_gdk_window_class);
    } else {
        lua_pushnil(L);
    }

    return 1;
}

// %% function:	hide	vo(GTK_WIDGET)
static int
ygtk_widget_hide (lua_State *L)
{
    gtk_widget_hide(GTK_WIDGET(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance));
    return 0;
}

#line 3091 "ygtk.c.in"

#line 3108 "ygtk.c.in"

// %% function:	queue_draw	vo(GTK_WIDGET)
static int
ygtk_widget_queue_draw (lua_State *L)
{
    gtk_widget_queue_draw(GTK_WIDGET(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance));
    return 0;
}

#line 3109 "ygtk.c.in"
// %% function:	realize	vo(GTK_WIDGET)
static int
ygtk_widget_realize (lua_State *L)
{
    gtk_widget_realize(GTK_WIDGET(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance));
    return 0;
}

#line 3110 "ygtk.c.in"

#line 3161 "ygtk.c.in"
// %% function:	show	vo(GTK_WIDGET)
static int
ygtk_widget_show (lua_State *L)
{
    gtk_widget_show(GTK_WIDGET(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance));
    return 0;
}

#line 3161 "ygtk.c.in"
// %% function:	show_all	vo(GTK_WIDGET)
static int
ygtk_widget_show_all (lua_State *L)
{
    gtk_widget_show_all(GTK_WIDGET(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance));
    return 0;
}

#line 3162 "ygtk.c.in"

static const luaL_Reg ylib_gtk_widget[] = {
#line 3166 "ygtk.c.in"
    { "SET_FLAGS",        ygtk_widget_SET_FLAGS },
#line 3169 "ygtk.c.in"
    { "get_window",       ygtk_widget_get_window },
#line 3175 "ygtk.c.in"
// %% ylib def:	gtk_widget
    { "add_events",        ygtk_widget_add_events },
    { "destroy",           ygtk_widget_destroy },
    { "hide",              ygtk_widget_hide },
    { "queue_draw",        ygtk_widget_queue_draw },
    { "realize",           ygtk_widget_realize },
    { "show",              ygtk_widget_show },
    { "show_all",          ygtk_widget_show_all },
#line 3175 "ygtk.c.in"
    { NULL, NULL }
};

/* GtkObject / GtkWidget / GtkContainer */

ygtk_class_data y_gtk_container_class = {
    "GtkContainer", "gtk", "container", &y_gtk_widget_class
};

// %% function:	add	vo(GTK_CONTAINER)o(GTK_WIDGET)
static int
ygtk_container_add (lua_State *L)
{
    gtk_container_add(GTK_CONTAINER(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance),
        GTK_WIDGET(((ygtk_object *)ygtk_checkuserdata(L, 2))->instance));
    return 0;
}

#line 3184 "ygtk.c.in"

#line 3200 "ygtk.c.in"

static const luaL_Reg ylib_gtk_container[] = {
#line 3203 "ygtk.c.in"
// %% ylib def:	gtk_container
    { "add",               ygtk_container_add },
#line 3203 "ygtk.c.in"
    { NULL, NULL }
};

/* GtkObject / GtkWidget / GtkContainer / GtkBin / GtkButton */

ygtk_class_data y_gtk_button_class = {
    "GtkButton", "gtk", "button", &y_gtk_container_class
};

// %% function:	new	Ov
static int
ygtk_button_new (lua_State *L)
{
    GObject *o;

    o = (GObject *)gtk_button_new();
    g_object_ref_sink(o);
    ygtk_make_object(L, o, &y_gtk_button_class);

    return 1;
}

#line 3212 "ygtk.c.in"
// %% function:	new_from_stock	Os
static int
ygtk_button_new_from_stock (lua_State *L)
{
    GObject *o;

    o = (GObject *)gtk_button_new_from_stock((const char *)luaL_checkstring(L, 1));
    g_object_ref_sink(o);
    ygtk_make_object(L, o, &y_gtk_button_class);

    return 1;
}

#line 3213 "ygtk.c.in"
// %% function:	new_with_label	Os
static int
ygtk_button_new_with_label (lua_State *L)
{
    GObject *o;

    o = (GObject *)gtk_button_new_with_label((const char *)luaL_checkstring(L, 1));
    g_object_ref_sink(o);
    ygtk_make_object(L, o, &y_gtk_button_class);

    return 1;
}

#line 3214 "ygtk.c.in"

static const luaL_Reg ylib_gtk_button[] = {
// %% ylib def:	gtk_button
    { "new",               ygtk_button_new },
    { "new_from_stock",    ygtk_button_new_from_stock },
    { "new_with_label",    ygtk_button_new_with_label },
#line 3217 "ygtk.c.in"
    { NULL, NULL }
};

/* GtkObject / GtkWidget / GtkContainer / GtkBin / GtkButton / GtkToggleButton */

ygtk_class_data y_gtk_toggle_button_class = {
    "GtkToggleButton", "gtk", "toggle_button", &y_gtk_button_class
};

/* -DOCNOTE- gtk_toggle_button_get_active(): can also use 'toggle_button:get("active")' */
// %% function:	get_active	bo(GTK_TOGGLE_BUTTON)
static int
ygtk_toggle_button_get_active (lua_State *L)
{
    gboolean b;

    b = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance));
    lua_pushboolean(L, b);
    return 1;
}

#line 3227 "ygtk.c.in"
// %% function:	new	Ov
static int
ygtk_toggle_button_new (lua_State *L)
{
    GObject *o;

    o = (GObject *)gtk_toggle_button_new();
    g_object_ref_sink(o);
    ygtk_make_object(L, o, &y_gtk_toggle_button_class);

    return 1;
}

#line 3228 "ygtk.c.in"

#line 3244 "ygtk.c.in"

static const luaL_Reg ylib_gtk_toggle_button[] = {
#line 3247 "ygtk.c.in"
// %% ylib def:	gtk_toggle_button
    { "get_active",        ygtk_toggle_button_get_active },
    { "new",               ygtk_toggle_button_new },
#line 3247 "ygtk.c.in"
    { NULL, NULL }
};

/* GtkObject / GtkWidget / GtkContainer / GtkBin / GtkButton / GtkToggleButton / GtkCheckButton */

ygtk_class_data y_gtk_check_button_class = {
    "GtkCheckButton", "gtk", "check_button", &y_gtk_toggle_button_class
};

// %% function:	new	Ov
static int
ygtk_check_button_new (lua_State *L)
{
    GObject *o;

    o = (GObject *)gtk_check_button_new();
    g_object_ref_sink(o);
    ygtk_make_object(L, o, &y_gtk_check_button_class);

    return 1;
}

#line 3256 "ygtk.c.in"
// %% function:	new_with_label	Os
static int
ygtk_check_button_new_with_label (lua_State *L)
{
    GObject *o;

    o = (GObject *)gtk_check_button_new_with_label((const char *)luaL_checkstring(L, 1));
    g_object_ref_sink(o);
    ygtk_make_object(L, o, &y_gtk_check_button_class);

    return 1;
}

#line 3257 "ygtk.c.in"

static const luaL_Reg ylib_gtk_check_button[] = {
// %% ylib def:	gtk_check_button
    { "new",               ygtk_check_button_new },
    { "new_with_label",    ygtk_check_button_new_with_label },
#line 3260 "ygtk.c.in"
    { NULL, NULL }
};

/* GtkObject / GtkWidget / GtkContainer / GtkBin / GtkComboBox */

ygtk_class_data y_gtk_combo_box_class = {
    "GtkComboBox", "gtk", "combo_box", &y_gtk_container_class
};

/* -DOCNOTE- this will accept one or more strings */
static int
ygtk_combo_box_append_text(lua_State *L)
{
    ygtk_object *w;
    int i;

    luaL_checktype(L, 1, LUA_TUSERDATA);
    
    w = lua_touserdata(L, 1);
    for (i = 2; i <= lua_gettop(L); i++) {
        const gchar *text = luaL_checkstring(L, i);

        gtk_combo_box_append_text(GTK_COMBO_BOX(w->instance), text);
    }

    return 0;
}

/* -DOCNOTE- gtk_combo_box_get_active(): can also use 'combo_box:get("active")' */
// %% function:	get_active	io(GTK_COMBO_BOX)
static int
ygtk_combo_box_get_active (lua_State *L)
{
    int i;

    i = gtk_combo_box_get_active(GTK_COMBO_BOX(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance));
    lua_pushnumber(L, (double)i);
    return 1;
}

#line 3289 "ygtk.c.in"

#line 3301 "ygtk.c.in"

static int
ygtk_combo_box_get_active_text(lua_State *L)
{
    ygtk_object *w;
    gchar *text;

    luaL_checktype(L, 1, LUA_TUSERDATA);
    
    w = lua_touserdata(L, 1);
    text = gtk_combo_box_get_active_text(GTK_COMBO_BOX(w->instance));
    lua_pushstring(L, text);
    g_free(text);

    return 1;
}

// %% function:	new_text	Ov
static int
ygtk_combo_box_new_text (lua_State *L)
{
    GObject *o;

    o = (GObject *)gtk_combo_box_new_text();
    g_object_ref_sink(o);
    ygtk_make_object(L, o, &y_gtk_combo_box_class);

    return 1;
}

#line 3318 "ygtk.c.in"

#line 3336 "ygtk.c.in"

// %% function:	set_active	vo(GTK_COMBO_BOX)i
static int
ygtk_combo_box_set_active (lua_State *L)
{
    gtk_combo_box_set_active(GTK_COMBO_BOX(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance),
        luaL_checkint(L, 2));
    return 0;
}

#line 3337 "ygtk.c.in"

#line 3349 "ygtk.c.in"

static const luaL_Reg ylib_gtk_combo_box[] = {
#line 3352 "ygtk.c.in"
    { "append_text",       ygtk_combo_box_append_text },
#line 3354 "ygtk.c.in"
    { "get_active_text",   ygtk_combo_box_get_active_text },
#line 3361 "ygtk.c.in"
// %% ylib def:	gtk_combo_box
    { "get_active",        ygtk_combo_box_get_active },
    { "new_text",          ygtk_combo_box_new_text },
    { "set_active",        ygtk_combo_box_set_active },
#line 3361 "ygtk.c.in"
    { NULL, NULL }
};

/* GtkObject / GtkWidget / GtkContainer / GtkBin / GtkFrame */

ygtk_class_data y_gtk_frame_class = {
    "GtkFrame", "gtk", "frame", &y_gtk_container_class
};

// %% function:	new	Os0
static int
ygtk_frame_new (lua_State *L)
{
    GObject *o;

    o = (GObject *)gtk_frame_new((lua_isnoneornil(L, 1) ? NULL : (const char *)luaL_checkstring(L, 1)));
    g_object_ref_sink(o);
    ygtk_make_object(L, o, &y_gtk_frame_class);

    return 1;
}

#line 3370 "ygtk.c.in"
#line 3389 "ygtk.c.in"

static const luaL_Reg ylib_gtk_frame[] = {
// %% ylib def:	gtk_frame
    { "new",               ygtk_frame_new },
#line 3391 "ygtk.c.in"
    { NULL, NULL }
};

#line 3490 "ygtk.c.in"

/* GtkObject / GtkWidget / GtkContainer / GtkBin / GtkScrolledWindow */

ygtk_class_data y_gtk_scrolled_window_class = {
    "GtkScrolledWindow", "gtk", "scrolled_window", &y_gtk_container_class
};

#line 3512 "ygtk.c.in"

static int
ygtk_scrolled_window_new(lua_State *L)
{
    ygtk_object *o;
    GtkAdjustment *ha, *va;
    GtkWidget *w;

    if (lua_isnil(L, 1)) {
        ha = NULL;
    } else {
        luaL_checktype(L, 1, LUA_TUSERDATA);
        o = lua_touserdata(L, 1);
        ha = GTK_ADJUSTMENT(o->instance);
    }
    if (lua_isnil(L, 2)) {
        va = NULL;
    } else {
        luaL_checktype(L, 2, LUA_TUSERDATA);
        o = lua_touserdata(L, 2);
        va = GTK_ADJUSTMENT(o->instance);
    }
    w = gtk_scrolled_window_new(ha, va);
    g_object_ref_sink(w);

    ygtk_make_object(L, G_OBJECT(w), &y_gtk_scrolled_window_class);

    return 1;
}

static const luaL_Reg ylib_gtk_scrolled_window[] = {
#line 3544 "ygtk.c.in"
    { "new",               ygtk_scrolled_window_new },
    { NULL, NULL }
};

#line 3587 "ygtk.c.in"

/* GtkObject / GtkWidget / GtkContainer / GtkBin / GtkWindow */

ygtk_class_data y_gtk_window_class = {
    "GtkWindow", "gtk", "window", &y_gtk_container_class
};

#line 3609 "ygtk.c.in"

static int
ygtk_window_get_size(lua_State *L)
{
    ygtk_object *w = ygtk_checkuserdata(L, 1);
    gint width, height;

    gtk_window_get_size(GTK_WINDOW(w->instance), &width, &height);
    lua_pushinteger(L, width);
    lua_pushinteger(L, height);

    return 2;
}

static int
ygtk_window_new(lua_State *L)
{
    GtkWindowType t;
    GtkWidget *w;

    /* -FIX- this allows omission of the parameter -- do I generally want to support that? */
    if (lua_gettop(L) >= 1) {
        luaL_checktype(L, 1, LUA_TNUMBER);
        t = (GtkWindowType)lua_tointeger(L, 1);
    } else
        t = GTK_WINDOW_TOPLEVEL;

    w = gtk_window_new(t);
    g_object_ref(w);  /* don't need g_object_ref_sink(), because all windows go on toplevel_list */

    ygtk_make_object(L, G_OBJECT(w), &y_gtk_window_class);

    return 1;
}

// %% function:	set_title	vo(GTK_WINDOW)s
static int
ygtk_window_set_title (lua_State *L)
{
    gtk_window_set_title(GTK_WINDOW(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance),
        (const char *)luaL_checkstring(L, 2));
    return 0;
}

#line 3644 "ygtk.c.in"

static const luaL_Reg ylib_gtk_window[] = {
#line 3648 "ygtk.c.in"
    { "get_size",        ygtk_window_get_size },
    { "new",             ygtk_window_new },
// %% ylib def:	gtk_window
    { "set_title",         ygtk_window_set_title },
#line 3650 "ygtk.c.in"
    { NULL, NULL }
};

#line 3802 "ygtk.c.in"

/* GtkObject / GtkWidget / GtkContainer / GtkBin / GtkWindow / GtkDialog */

ygtk_class_data y_gtk_dialog_class = {
    "GtkDialog", "gtk", "dialog", &y_gtk_window_class
};

ygtk_class_data y_gtk_vbox_class; /* forward */

/* -FIX- -DOCNOTE- GtkDialog:add_button() does not return the button */
// %% function:	add_button	vo(GTK_DIALOG)si
static int
ygtk_dialog_add_button (lua_State *L)
{
    gtk_dialog_add_button(GTK_DIALOG(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance),
        (const char *)luaL_checkstring(L, 2),
        luaL_checkint(L, 3));
    return 0;
}

#line 3812 "ygtk.c.in"

static int
ygtk_dialog_get_action_area(lua_State *L)
{
    ygtk_object *d = ygtk_checkuserdata(L, 1);
    GtkWidget *vbox;

#if GTK_CHECK_VERSION(2, 14, 0)
    vbox = gtk_dialog_get_action_area(GTK_DIALOG(d->instance));
#else
    vbox = GTK_DIALOG(d->instance)->action_area;
#endif
    g_object_ref(vbox);  /* need to add a ref for the gc to unref */

    ygtk_make_object(L, G_OBJECT(vbox), &y_gtk_vbox_class);
    
    return 1;
}

static int
ygtk_dialog_get_content_area(lua_State *L)
{
    ygtk_object *d = ygtk_checkuserdata(L, 1);
    GtkWidget *vbox;

#if GTK_CHECK_VERSION(2, 14, 0)
    vbox = gtk_dialog_get_content_area(GTK_DIALOG(d->instance));
#else
    vbox = GTK_DIALOG(d->instance)->vbox;
#endif
    g_object_ref(vbox);  /* need to add a ref for the gc to unref */

    ygtk_make_object(L, G_OBJECT(vbox), &y_gtk_vbox_class);
    
    return 1;
}

static int
ygtk_dialog_new_with_buttons(lua_State *L)
{
    const gchar *title = luaL_checkstring(L, 1);
    GtkWindow *parent = lua_isnil(L, 2) ? NULL : (GtkWindow *)((ygtk_object *)ygtk_checkuserdata(L, 2))->instance;
    guint flags = luaL_checkinteger(L, 3);
    int p;
    const gchar *text[4];
    gint id[4];
    GtkWidget *dialog;

    /* -FIX- could work around limit with gtk_dialog_add_button() */
    if (lua_gettop(L) > 12) {
        fprintf(stderr, "ERROR: ygtk_dialog_new_with_buttons does not support more than four button pairs\n"); /* -DOCNOTE- */
    }
    for (p = 4; p <= 10; p += 2) {
       if (p <= lua_gettop(L)) {
           text[(p - 4) >> 1] = luaL_checkstring(L, p);
           id[((p - 4) >> 1) + 1] = luaL_checkinteger(L, p + 1);
       } else
           text[(p - 4) >> 1] = NULL;
    }
    dialog = gtk_dialog_new_with_buttons(title, parent, flags,
                                         text[0], id[0], text[1], id[1], 
                                         text[2], id[2], text[3], id[3], NULL);
    g_object_ref_sink(dialog);

    ygtk_make_object(L, G_OBJECT(dialog), &y_gtk_dialog_class);

    return 1;

}

// %% function:	run	io(GTK_DIALOG)
static int
ygtk_dialog_run (lua_State *L)
{
    int i;

    i = gtk_dialog_run(GTK_DIALOG(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance));
    lua_pushnumber(L, (double)i);
    return 1;
}

#line 3883 "ygtk.c.in"

static const luaL_Reg ylib_gtk_dialog[] = {
    { "get_action_area",   ygtk_dialog_get_action_area },
    { "get_content_area",  ygtk_dialog_get_content_area },
    { "new_with_buttons",  ygtk_dialog_new_with_buttons },
// %% ylib def:	gtk_dialog
    { "add_button",        ygtk_dialog_add_button },
    { "run",               ygtk_dialog_run },
#line 3889 "ygtk.c.in"
    { NULL, NULL }
};

/* GtkObject / GtkWidget / GtkContainer / GtkBin / GtkWindow / GtkDialog / GtkAboutDialog */

ygtk_class_data y_gtk_about_dialog_class = {
    "GtkAboutDialog", "gtk", "about_dialog", &y_gtk_dialog_class
};

// %% function:	new	Ov
static int
ygtk_about_dialog_new (lua_State *L)
{
    GObject *o;

    o = (GObject *)gtk_about_dialog_new();
    g_object_ref_sink(o);
    ygtk_make_object(L, o, &y_gtk_about_dialog_class);

    return 1;
}

#line 3898 "ygtk.c.in"

static const luaL_Reg ylib_gtk_about_dialog[] = {
// %% ylib def:	gtk_about_dialog
    { "new",               ygtk_about_dialog_new },
#line 3901 "ygtk.c.in"
    { NULL, NULL }
};

#line 4006 "ygtk.c.in"

/* GtkObject / GtkWidget / GtkContainer / GtkBox */

ygtk_class_data y_gtk_box_class = {
    "GtkBox", "gtk", "box", &y_gtk_container_class
};

// %% function:	pack_end	vo(GTK_BOX)o(GTK_WIDGET)bbi
static int
ygtk_box_pack_end (lua_State *L)
{
    gtk_box_pack_end(GTK_BOX(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance),
        GTK_WIDGET(((ygtk_object *)ygtk_checkuserdata(L, 2))->instance),
        lua_toboolean(L, 3),
        lua_toboolean(L, 4),
        luaL_checkint(L, 5));
    return 0;
}

#line 4013 "ygtk.c.in"
// %% function:	pack_start	vo(GTK_BOX)o(GTK_WIDGET)bbi
static int
ygtk_box_pack_start (lua_State *L)
{
    gtk_box_pack_start(GTK_BOX(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance),
        GTK_WIDGET(((ygtk_object *)ygtk_checkuserdata(L, 2))->instance),
        lua_toboolean(L, 3),
        lua_toboolean(L, 4),
        luaL_checkint(L, 5));
    return 0;
}

#line 4014 "ygtk.c.in"

static const luaL_Reg ylib_gtk_box[] = {
// %% ylib def:	gtk_box
    { "pack_end",          ygtk_box_pack_end },
    { "pack_start",        ygtk_box_pack_start },
#line 4017 "ygtk.c.in"
    { NULL, NULL }
};

/* GtkObject / GtkWidget / GtkContainer / GtkBox / GtkHBox */

ygtk_class_data y_gtk_hbox_class = {
    "GtkHBox", "gtk", "hbox", &y_gtk_box_class,
};

// %% function:	new	Obi
static int
ygtk_hbox_new (lua_State *L)
{
    GObject *o;

    o = (GObject *)gtk_hbox_new(lua_toboolean(L, 1),
            luaL_checkint(L, 2));
    g_object_ref_sink(o);
    ygtk_make_object(L, o, &y_gtk_hbox_class);

    return 1;
}

#line 4026 "ygtk.c.in"

static const luaL_Reg ylib_gtk_hbox[] = {
// %% ylib def:	gtk_hbox
    { "new",               ygtk_hbox_new },
#line 4029 "ygtk.c.in"
    { NULL, NULL }
};

/* GtkObject / GtkWidget / GtkContainer / GtkBox / GtkVBox */

ygtk_class_data y_gtk_vbox_class = {
    "GtkVBox", "gtk", "vbox", &y_gtk_box_class
};

// %% function:	new	Obi
static int
ygtk_vbox_new (lua_State *L)
{
    GObject *o;

    o = (GObject *)gtk_vbox_new(lua_toboolean(L, 1),
            luaL_checkint(L, 2));
    g_object_ref_sink(o);
    ygtk_make_object(L, o, &y_gtk_vbox_class);

    return 1;
}

#line 4038 "ygtk.c.in"

static const luaL_Reg ylib_gtk_vbox[] = {
// %% ylib def:	gtk_vbox
    { "new",               ygtk_vbox_new },
#line 4041 "ygtk.c.in"
    { NULL, NULL }
};

#line 4069 "ygtk.c.in"

#ifdef GTK_TYPE_CONTROL
/* GtkObject / GtkWidget / GtkContainer / GtkControlPanel (see also GtkControl) */

ygtk_class_data y_gtk_control_panel_class = {
    "GtkControlPanel", "gtk", "control_panel", &y_gtk_container_class
};

// %% function:	new	Oo(GDK_PIXBUF)ii
static int
ygtk_control_panel_new (lua_State *L)
{
    GObject *o;

    o = (GObject *)gtk_control_panel_new(GDK_PIXBUF(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance),
            luaL_checkint(L, 2),
            luaL_checkint(L, 3));
    g_object_ref_sink(o);
    ygtk_make_object(L, o, &y_gtk_control_panel_class);

    return 1;
}

#line 4077 "ygtk.c.in"
// %% function:	put	vo(GTK_CONTROL_PANEL)o(GTK_WIDGET)ii
static int
ygtk_control_panel_put (lua_State *L)
{
    gtk_control_panel_put(GTK_CONTROL_PANEL(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance),
        GTK_WIDGET(((ygtk_object *)ygtk_checkuserdata(L, 2))->instance),
        luaL_checkint(L, 3),
        luaL_checkint(L, 4));
    return 0;
}

#line 4078 "ygtk.c.in"

static const luaL_Reg ylib_gtk_control_panel[] = {
// %% ylib def:	gtk_control_panel
    { "new",               ygtk_control_panel_new },
    { "put",               ygtk_control_panel_put },
#line 4081 "ygtk.c.in"
    { NULL, NULL }
};
#endif /* GTK_TYPE_CONTROL */

#line 4289 "ygtk.c.in"

/* GtkObject / GtkWidget / GtkContainer / GtkTable */

ygtk_class_data y_gtk_table_class = {
    "GtkTable", "gtk", "table", &y_gtk_container_class
};

// %% function:	attach	vo(GTK_TABLE)o(GTK_WIDGET)iiiiiiii
static int
ygtk_table_attach (lua_State *L)
{
    gtk_table_attach(GTK_TABLE(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance),
        GTK_WIDGET(((ygtk_object *)ygtk_checkuserdata(L, 2))->instance),
        luaL_checkint(L, 3),
        luaL_checkint(L, 4),
        luaL_checkint(L, 5),
        luaL_checkint(L, 6),
        luaL_checkint(L, 7),
        luaL_checkint(L, 8),
        luaL_checkint(L, 9),
        luaL_checkint(L, 10));
    return 0;
}

#line 4296 "ygtk.c.in"
// %% function:	new	Oiib
static int
ygtk_table_new (lua_State *L)
{
    GObject *o;

    o = (GObject *)gtk_table_new(luaL_checkint(L, 1),
            luaL_checkint(L, 2),
            lua_toboolean(L, 3));
    g_object_ref_sink(o);
    ygtk_make_object(L, o, &y_gtk_table_class);

    return 1;
}

#line 4297 "ygtk.c.in"

static const luaL_Reg ylib_gtk_table[] = {
// %% ylib def:	gtk_table
    { "attach",            ygtk_table_attach },
    { "new",               ygtk_table_new },
#line 4300 "ygtk.c.in"
    { NULL, NULL }
};

/* GtkObject / GtkWidget / GtkContainer / GtkTextView */

ygtk_class_data y_gtk_text_view_class = {
    "GtkTextView", "gtk", "text_view", &y_gtk_container_class
};

static int
ygtk_text_view_get_buffer(lua_State *L)
{
    ygtk_object *v = ygtk_checkuserdata(L, 1);
    GtkTextBuffer *b = gtk_text_view_get_buffer(GTK_TEXT_VIEW(v->instance));

    g_object_ref(b);
    ygtk_make_object(L, G_OBJECT(b), &y_gtk_text_buffer_class);

    return 1;
}

// %% function:	new	Ov
static int
ygtk_text_view_new (lua_State *L)
{
    GObject *o;

    o = (GObject *)gtk_text_view_new();
    g_object_ref_sink(o);
    ygtk_make_object(L, o, &y_gtk_text_view_class);

    return 1;
}

#line 4321 "ygtk.c.in"

static int
ygtk_text_view_scroll_to_mark_by_name(lua_State *L)  /* -DOCNOTE- by name, so we don't need to handle GtkTextMarks */
{
    /* -DOCNOTE- view:scroll_to_mark_by_name(mark_name, within_margin, use_align, xalign, yalign) */
    ygtk_object *o = ygtk_checkuserdata(L, 1);
    GtkTextBuffer *b = gtk_text_view_get_buffer(GTK_TEXT_VIEW(o->instance));
    GtkTextMark *m = gtk_text_buffer_get_mark(b, luaL_checkstring(L, 2));

    if (m)
        gtk_text_view_scroll_to_mark(GTK_TEXT_VIEW(o->instance), m,
                                     luaL_checknumber(L, 3),
                                     lua_toboolean(L, 4),
                                     (lua_gettop(L) > 4 ? luaL_checknumber(L, 5) : 0.0),
                                     (lua_gettop(L) > 4 ? luaL_checknumber(L, 6) : 0.0));

    return 0;
}

static const luaL_Reg ylib_gtk_text_view[] = {
    { "get_buffer",    ygtk_text_view_get_buffer },
    { "scroll_to_mark_by_name", ygtk_text_view_scroll_to_mark_by_name },
// %% ylib def:	gtk_text_view
    { "new",               ygtk_text_view_new },
#line 4344 "ygtk.c.in"
    { NULL, NULL }
};

#line 4436 "ygtk.c.in"

/* GtkObject / GtkWidget / GtkDrawingArea */

ygtk_class_data y_gtk_drawing_area_class = {
    "GtkDrawingArea", "gtk", "drawing_area", &y_gtk_widget_class
};

// %% function:	new	Ov
static int
ygtk_drawing_area_new (lua_State *L)
{
    GObject *o;

    o = (GObject *)gtk_drawing_area_new();
    g_object_ref_sink(o);
    ygtk_make_object(L, o, &y_gtk_drawing_area_class);

    return 1;
}

#line 4443 "ygtk.c.in"

static const luaL_Reg ylib_gtk_drawing_area[] = {
// %% ylib def:	gtk_drawing_area
    { "new",               ygtk_drawing_area_new },
#line 4446 "ygtk.c.in"
    { NULL, NULL }
};

/* GtkObject / GtkWidget / GtkEntry */

ygtk_class_data y_gtk_entry_class = {
    "GtkEntry", "gtk", "entry", &y_gtk_widget_class
};

#line 4501 "ygtk.c.in"

/* GtkObject / GtkWidget / GtkEntry / GtkSpinButton */

ygtk_class_data y_gtk_spin_button_class = {
    "GtkSpinButton", "gtk", "spin_button", &y_gtk_entry_class
};

// %% function:	new	Oo(GTK_ADJUSTMENT)dd
static int
ygtk_spin_button_new (lua_State *L)
{
    GObject *o;

    o = (GObject *)gtk_spin_button_new(GTK_ADJUSTMENT(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance),
            luaL_checknumber(L, 2),
            luaL_checknumber(L, 3));
    g_object_ref_sink(o);
    ygtk_make_object(L, o, &y_gtk_spin_button_class);

    return 1;
}

#line 4508 "ygtk.c.in"

static const luaL_Reg ylib_gtk_spin_button[] = {
// %% ylib def:	gtk_spin_button
    { "new",               ygtk_spin_button_new },
#line 4511 "ygtk.c.in"
    { NULL, NULL }
};

/* GtkObject / GtkWidget / GtkMisc / GtkImage */

ygtk_class_data y_gtk_image_class = {
    "GtkImage", "gtk", "image", &y_gtk_widget_class
};

// %% function:	new_from_file	Os
static int
ygtk_image_new_from_file (lua_State *L)
{
    GObject *o;

    o = (GObject *)gtk_image_new_from_file((const char *)luaL_checkstring(L, 1));
    g_object_ref_sink(o);
    ygtk_make_object(L, o, &y_gtk_image_class);

    return 1;
}

#line 4520 "ygtk.c.in"

#line 4534 "ygtk.c.in"

static const luaL_Reg ylib_gtk_image[] = {
#line 4537 "ygtk.c.in"
// %% ylib def:	gtk_image
    { "new_from_file",     ygtk_image_new_from_file },
#line 4537 "ygtk.c.in"
    { NULL, NULL }
};

/* GtkObject / GtkWidget / GtkMisc / GtkLabel */

ygtk_class_data y_gtk_label_class = {
    "GtkLabel", "gtk", "label", &y_gtk_widget_class
};

// %% function:	new	Os0
static int
ygtk_label_new (lua_State *L)
{
    GObject *o;

    o = (GObject *)gtk_label_new((lua_isnoneornil(L, 1) ? NULL : (const char *)luaL_checkstring(L, 1)));
    g_object_ref_sink(o);
    ygtk_make_object(L, o, &y_gtk_label_class);

    return 1;
}

#line 4546 "ygtk.c.in"
// %% function:	set_text	vo(GTK_LABEL)s
static int
ygtk_label_set_text (lua_State *L)
{
    gtk_label_set_text(GTK_LABEL(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance),
        (const char *)luaL_checkstring(L, 2));
    return 0;
}

#line 4547 "ygtk.c.in"

static const luaL_Reg ylib_gtk_label[] = {
// %% ylib def:	gtk_label
    { "new",               ygtk_label_new },
    { "set_text",          ygtk_label_set_text },
#line 4550 "ygtk.c.in"
    { NULL, NULL }
};

/* GtkObject / GtkWidget / GtkProgress / GtkProgressBar */

ygtk_class_data y_gtk_progress_bar_class = {
    "GtkProgressBar", "gtk", "progress_bar", &y_gtk_widget_class
};

// %% function:	new	Ov
static int
ygtk_progress_bar_new (lua_State *L)
{
    GObject *o;

    o = (GObject *)gtk_progress_bar_new();
    g_object_ref_sink(o);
    ygtk_make_object(L, o, &y_gtk_progress_bar_class);

    return 1;
}

#line 4559 "ygtk.c.in"
// %% function:	set_fraction	vo(GTK_PROGRESS_BAR)d
static int
ygtk_progress_bar_set_fraction (lua_State *L)
{
    gtk_progress_bar_set_fraction(GTK_PROGRESS_BAR(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance),
        luaL_checknumber(L, 2));
    return 0;
}

#line 4560 "ygtk.c.in"

static const luaL_Reg ylib_gtk_progress_bar[] = {
// %% ylib def:	gtk_progress_bar
    { "new",               ygtk_progress_bar_new },
    { "set_fraction",      ygtk_progress_bar_set_fraction },
#line 4563 "ygtk.c.in"
    { NULL, NULL }
};

/* GtkObject / GtkWidget / GtkRange */

ygtk_class_data y_gtk_range_class = {
    "GtkRange", "gtk", "range", &y_gtk_widget_class
};

#line 4588 "ygtk.c.in"

static const luaL_Reg ylib_gtk_range[] = {
#line 4591 "ygtk.c.in"
    { NULL, NULL }
};

#ifdef GTK_TYPE_CONTROL
/* GtkObject / GtkWidget / GtkRange / GtkControl (see also GtkControlPanel) */

ygtk_class_data y_gtk_control_class = {
    "GtkControl", "gtk", "control", &y_gtk_range_class
};

// %% function:	new	Oo(GTK_ADJUSTMENT)o(GDK_PIXBUF)iiiiiiii
static int
ygtk_control_new (lua_State *L)
{
    GObject *o;

    o = (GObject *)gtk_control_new(GTK_ADJUSTMENT(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance),
            GDK_PIXBUF(((ygtk_object *)ygtk_checkuserdata(L, 2))->instance),
            luaL_checkint(L, 3),
            luaL_checkint(L, 4),
            luaL_checkint(L, 5),
            luaL_checkint(L, 6),
            luaL_checkint(L, 7),
            luaL_checkint(L, 8),
            luaL_checkint(L, 9),
            luaL_checkint(L, 10));
    g_object_ref_sink(o);
    ygtk_make_object(L, o, &y_gtk_control_class);

    return 1;
}

#line 4601 "ygtk.c.in"
// %% function:	set_prelight_offsets	vo(GTK_CONTROL)ii
static int
ygtk_control_set_prelight_offsets (lua_State *L)
{
    gtk_control_set_prelight_offsets(GTK_CONTROL(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance),
        luaL_checkint(L, 2),
        luaL_checkint(L, 3));
    return 0;
}

#line 4602 "ygtk.c.in"
// %% function:	set_widget_bg_parent_relative_in_style	vo(GTK_WIDGET)
static int
ygtk_control_set_widget_bg_parent_relative_in_style (lua_State *L)
{
    gtk_control_set_widget_bg_parent_relative_in_style(GTK_WIDGET(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance));
    return 0;
}

#line 4603 "ygtk.c.in"

static const luaL_Reg ylib_gtk_control[] = {
// %% ylib def:	gtk_control
    { "new",               ygtk_control_new },
    { "set_prelight_offsets", ygtk_control_set_prelight_offsets },
    { "set_widget_bg_parent_relative_in_style", ygtk_control_set_widget_bg_parent_relative_in_style },
#line 4606 "ygtk.c.in"
    { NULL, NULL }
};
#endif /* GTK_TYPE_CONTROL */

#ifdef GTK_TYPE_KNOB
/* GtkObject / GtkWidget / GtkRange / GtkKnob */

ygtk_class_data y_gtk_knob_class = {
    "GtkKnob", "gtk", "knob", &y_gtk_range_class
};

// %% function:	new	Oo(GTK_ADJUSTMENT)
static int
ygtk_knob_new (lua_State *L)
{
    GObject *o;

    o = (GObject *)gtk_knob_new(GTK_ADJUSTMENT(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance));
    g_object_ref_sink(o);
    ygtk_make_object(L, o, &y_gtk_knob_class);

    return 1;
}

#line 4617 "ygtk.c.in"

static const luaL_Reg ylib_gtk_knob[] = {
// %% ylib def:	gtk_knob
    { "new",               ygtk_knob_new },
#line 4620 "ygtk.c.in"
    { NULL, NULL }
};
#endif /* GTK_TYPE_KNOB */

/* GtkObject / GtkWidget / GtkRange / GtkScale / GtkHScale */

ygtk_class_data y_gtk_hscale_class = {
    "GtkHScale", "gtk", "hscale", &y_gtk_range_class
};

// %% function:	new	Oo(GTK_ADJUSTMENT)
static int
ygtk_hscale_new (lua_State *L)
{
    GObject *o;

    o = (GObject *)gtk_hscale_new(GTK_ADJUSTMENT(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance));
    g_object_ref_sink(o);
    ygtk_make_object(L, o, &y_gtk_hscale_class);

    return 1;
}

#line 4630 "ygtk.c.in"
// %% function:	new_with_range	Oddd
static int
ygtk_hscale_new_with_range (lua_State *L)
{
    GObject *o;

    o = (GObject *)gtk_hscale_new_with_range(luaL_checknumber(L, 1),
            luaL_checknumber(L, 2),
            luaL_checknumber(L, 3));
    g_object_ref_sink(o);
    ygtk_make_object(L, o, &y_gtk_hscale_class);

    return 1;
}

#line 4631 "ygtk.c.in"

static const luaL_Reg ylib_gtk_hscale[] = {
// %% ylib def:	gtk_hscale
    { "new",               ygtk_hscale_new },
    { "new_with_range",    ygtk_hscale_new_with_range },
#line 4634 "ygtk.c.in"
    { NULL, NULL }
};

/* GtkObject / GtkWidget / GtkRange / GtkScale / GtkVScale */

ygtk_class_data y_gtk_vscale_class = {
    "GtkVScale", "gtk", "vscale", &y_gtk_range_class
};

// %% function:	new	Oo(GTK_ADJUSTMENT)
static int
ygtk_vscale_new (lua_State *L)
{
    GObject *o;

    o = (GObject *)gtk_vscale_new(GTK_ADJUSTMENT(((ygtk_object *)ygtk_checkuserdata(L, 1))->instance));
    g_object_ref_sink(o);
    ygtk_make_object(L, o, &y_gtk_vscale_class);

    return 1;
}

#line 4643 "ygtk.c.in"
// %% function:	new_with_range	Oddd
static int
ygtk_vscale_new_with_range (lua_State *L)
{
    GObject *o;

    o = (GObject *)gtk_vscale_new_with_range(luaL_checknumber(L, 1),
            luaL_checknumber(L, 2),
            luaL_checknumber(L, 3));
    g_object_ref_sink(o);
    ygtk_make_object(L, o, &y_gtk_vscale_class);

    return 1;
}

#line 4644 "ygtk.c.in"

static const luaL_Reg ylib_gtk_vscale[] = {
// %% ylib def:	gtk_vscale
    { "new",               ygtk_vscale_new },
    { "new_with_range",    ygtk_vscale_new_with_range },
#line 4647 "ygtk.c.in"
    { NULL, NULL }
};

/* GtkObject / GtkWidget / GtkSeparator / GtkHSeparator */

ygtk_class_data y_gtk_hseparator_class = {
    "GtkHSeparator", "gtk", "hseparator", &y_gtk_widget_class
};

// %% function:	new	Ov
static int
ygtk_hseparator_new (lua_State *L)
{
    GObject *o;

    o = (GObject *)gtk_hseparator_new();
    g_object_ref_sink(o);
    ygtk_make_object(L, o, &y_gtk_hseparator_class);

    return 1;
}

#line 4656 "ygtk.c.in"

static const luaL_Reg ylib_gtk_hseparator[] = {
// %% ylib def:	gtk_hseparator
    { "new",               ygtk_hseparator_new },
#line 4659 "ygtk.c.in"
    { NULL, NULL }
};

/* initialization and enumerations */

static const char *ygtk_init_string = 
#if !defined(YGTK_STANDALONE) && LUA_VERSION_NUM < 502
        "package.loaded['ygtk'] = gtk\n"   /* for compatibility with stand-alone ygtk scripts */
#endif
        "g.set = g.object_set_property\n"  /* syntactic sugar */
        "g.get = g.object_get_property\n"; /* syntactic sugar */
        /* g.boxed.__index = g.boxed   -- does not inherit (yet) */

static const ygtk_enum_data yg_enums[] = {
    /* GFileTest */
    { "FILE_TEST_IS_REGULAR",    G_FILE_TEST_IS_REGULAR },
    { "FILE_TEST_IS_SYMLINK",    G_FILE_TEST_IS_SYMLINK },
    { "FILE_TEST_IS_DIR",        G_FILE_TEST_IS_DIR },
    { "FILE_TEST_IS_EXECUTABLE", G_FILE_TEST_IS_EXECUTABLE },
    { "FILE_TEST_EXISTS",        G_FILE_TEST_EXISTS },
    { NULL, 0 }
};

static const ygtk_enum_data ycairo_enums[] = {
    { "FONT_SLANT_NORMAL",   CAIRO_FONT_SLANT_NORMAL },
#line 4685 "ygtk.c.in"
    { "FONT_WEIGHT_BOLD",    CAIRO_FONT_WEIGHT_BOLD },
#line 4687 "ygtk.c.in"
    { "FORMAT_RGB24",        CAIRO_FORMAT_RGB24 },
    { "LINE_CAP_BUTT",       CAIRO_LINE_CAP_BUTT },
    { "LINE_CAP_ROUND",      CAIRO_LINE_CAP_ROUND },
    { "LINE_CAP_SQUARE",     CAIRO_LINE_CAP_SQUARE },
#line 4693 "ygtk.c.in"
    { NULL, 0 }
};

static const ygtk_enum_data ypango_enums[] = {
    { "SCALE",               PANGO_SCALE },
    { "STYLE_ITALIC",        PANGO_STYLE_ITALIC },
    { "UNDERLINE_SINGLE",    PANGO_UNDERLINE_SINGLE },
    { "WEIGHT_BOLD",         PANGO_WEIGHT_BOLD },
    { NULL, 0 }
};

static const ygtk_enum_data ygdk_enums[] = {
    /* GdkEventMask (gdkevents.h) */
    { "EXPOSURE_MASK",       GDK_EXPOSURE_MASK },
    { "BUTTON1_MOTION_MASK", GDK_BUTTON1_MOTION_MASK },
    { "BUTTON_PRESS_MASK",   GDK_BUTTON_PRESS_MASK },
    { "BUTTON_RELEASE_MASK", GDK_BUTTON_RELEASE_MASK },
    { "KEY_PRESS_MASK",      GDK_KEY_PRESS_MASK },
    { "SCROLL_MASK",         GDK_SCROLL_MASK },
#line 4714 "ygtk.c.in"
    { NULL, 0 }
};

static const ygtk_enum_data ygtk_enums[] = {
    /* */
    { "EXPAND",              GTK_EXPAND },
    { "SHRINK",              GTK_SHRINK },
    { "FILL",                GTK_FILL },
#line 4726 "ygtk.c.in"
    { "POLICY_AUTOMATIC",    GTK_POLICY_AUTOMATIC },
#line 4729 "ygtk.c.in"
    { "POS_RIGHT",           GTK_POS_RIGHT },
#line 4734 "ygtk.c.in"
    /* */
    { "WINDOW_TOPLEVEL",     GTK_WINDOW_TOPLEVEL },
#line 4745 "ygtk.c.in"
#ifdef GTK_TYPE_CONTROL
    /* GtkControlType (gtkcontrol.h) */
    { "CONTROL_ROTARY",      GTK_CONTROL_ROTARY },
    { "CONTROL_HORIZONTAL",  GTK_CONTROL_HORIZONTAL },
    { "CONTROL_VERTICAL",    GTK_CONTROL_VERTICAL },
    { "CONTROL_DRAWBAR",     GTK_CONTROL_DRAWBAR },
    { "CONTROL_BUTTON",      GTK_CONTROL_BUTTON },
    { "CONTROL_SWITCH",      GTK_CONTROL_SWITCH },
    { "CONTROL_RADIO",       GTK_CONTROL_RADIO },
#endif
#line 4757 "ygtk.c.in"
    /* GtkJustification (gtkenums.h) */
    { "JUSTIFY_CENTER",      GTK_JUSTIFY_CENTER },
#line 4761 "ygtk.c.in"
    /* GtkResponseType (gtkdialog.h) */
#line 4763 "ygtk.c.in"
    { "RESPONSE_CANCEL",     GTK_RESPONSE_CANCEL },
#line 4777 "ygtk.c.in"
    /* GtkUpdateType */
    { "UPDATE_CONTINUOUS",   GTK_UPDATE_CONTINUOUS },
    { "UPDATE_DELAYED",      GTK_UPDATE_DELAYED },
    /* GtkWidgetFlags (gtkwidget.h) */
    { "CAN_FOCUS",           GTK_CAN_FOCUS },
#line 4783 "ygtk.c.in"
    /* GtkWrapMode (gtkenums.h) */
    { "WRAP_WORD",           GTK_WRAP_WORD },
    { NULL, 0 }
};

/* open ygtk library */
LUALIB_API int
luaopen_ygtk (lua_State *L)
{
    int top;

    ygtk_register(L, "g",       ylib_g);
    ygtk_set_enums(L, yg_enums);
    lua_remove(L, -1);                        /* 'gtk' is the table we'll return, so drop 'g' */
    ygtk_register(L, "cairo",   ylib_cairo);
    ygtk_set_enums(L, ycairo_enums);
    lua_remove(L, -1);
    ygtk_register(L, "pango",   ylib_pango);
    ygtk_set_enums(L, ypango_enums);
    lua_remove(L, -1);
    ygtk_register(L, "gdk",     ylib_gdk);
    ygtk_set_enums(L, ygdk_enums);
    lua_remove(L, -1);
    ygtk_register(L, "gtk",     ylib_gtk);    /* -- gtk */
    ygtk_set_enums(L, ygtk_enums);
    top = lua_gettop(L);
    if (luaL_dostring(L, ygtk_init_string) != 0) {
        fprintf(stderr, "error message: %s\n", lua_tostring(L, -1));
    }
    lua_settop(L, top);  /* clear stack of any results of the above */
    ygtk_class_pointer_quark = g_quark_from_string ("ygtk_class_pointer");
    ygtk_build_simple_class(L, "g.boxed",             ylib_g_boxed);
#line 4816 "ygtk.c.in"
    ygtk_build_simple_class(L, "cairo.context",       ylib_cairo_context);
    ygtk_build_simple_class(L, "cairo.surface",       ylib_cairo_surface);
    ygtk_build_simple_class(L, "cairo.image_surface", ylib_cairo_image_surface);
#line 4820 "ygtk.c.in"
    ygtk_build_class(L, &y_gdk_drawable_class,             ylib_gdk_drawable);
    ygtk_build_class(L, &y_gdk_window_class,               ylib_gdk_window);
    ygtk_build_class(L, &y_gdk_pixbuf_class,               ylib_gdk_pixbuf);
#line 4828 "ygtk.c.in"
    ygtk_build_class(L, &y_gtk_text_buffer_class,          ylib_gtk_text_buffer);
#line 4831 "ygtk.c.in"
    ygtk_build_class(L, &y_gtk_adjustment_class,           ylib_gtk_adjustment);
#line 4836 "ygtk.c.in"
    ygtk_build_class(L, &y_gtk_widget_class,               ylib_gtk_widget);
    ygtk_build_class(L, &y_gtk_container_class,            ylib_gtk_container);
    ygtk_build_class(L, &y_gtk_button_class,               ylib_gtk_button);
    ygtk_build_class(L, &y_gtk_toggle_button_class,        ylib_gtk_toggle_button);
    ygtk_build_class(L, &y_gtk_check_button_class,         ylib_gtk_check_button);
    ygtk_build_class(L, &y_gtk_combo_box_class,            ylib_gtk_combo_box);
    ygtk_build_class(L, &y_gtk_frame_class,                ylib_gtk_frame);
#line 4845 "ygtk.c.in"
    ygtk_build_class(L, &y_gtk_scrolled_window_class,      ylib_gtk_scrolled_window);
#line 4847 "ygtk.c.in"
    ygtk_build_class(L, &y_gtk_window_class,               ylib_gtk_window);
#line 4849 "ygtk.c.in"
    ygtk_build_class(L, &y_gtk_dialog_class,               ylib_gtk_dialog);
    ygtk_build_class(L, &y_gtk_about_dialog_class,         ylib_gtk_about_dialog);
#line 4853 "ygtk.c.in"
    ygtk_build_class(L, &y_gtk_box_class,                  ylib_gtk_box);
    ygtk_build_class(L, &y_gtk_hbox_class,                 ylib_gtk_hbox);
    ygtk_build_class(L, &y_gtk_vbox_class,                 ylib_gtk_vbox);
#line 4857 "ygtk.c.in"
#ifdef GTK_TYPE_CONTROL
    ygtk_build_class(L, &y_gtk_control_panel_class,        ylib_gtk_control_panel);
#endif
#line 4864 "ygtk.c.in"
    ygtk_build_class(L, &y_gtk_table_class,                ylib_gtk_table);
    ygtk_build_class(L, &y_gtk_text_view_class,            ylib_gtk_text_view);
#line 4867 "ygtk.c.in"
    ygtk_build_class(L, &y_gtk_drawing_area_class,         ylib_gtk_drawing_area);
#line 4869 "ygtk.c.in"
    ygtk_build_class(L, &y_gtk_spin_button_class,          ylib_gtk_spin_button);
    ygtk_build_class(L, &y_gtk_image_class,                ylib_gtk_image);
    ygtk_build_class(L, &y_gtk_label_class,                ylib_gtk_label);
    ygtk_build_class(L, &y_gtk_progress_bar_class,         ylib_gtk_progress_bar);
    ygtk_build_class(L, &y_gtk_range_class,                ylib_gtk_range);
#ifdef GTK_TYPE_CONTROL
    ygtk_build_class(L, &y_gtk_control_class,              ylib_gtk_control);
#endif
#ifdef GTK_TYPE_KNOB
    ygtk_build_class(L, &y_gtk_knob_class,                 ylib_gtk_knob);
#endif
    ygtk_build_class(L, &y_gtk_hscale_class,               ylib_gtk_hscale);
    ygtk_build_class(L, &y_gtk_vscale_class,               ylib_gtk_vscale);
    ygtk_build_class(L, &y_gtk_hseparator_class,           ylib_gtk_hseparator);

    if (top != lua_gettop(L))
        fprintf(stderr, "luaopen_ygtk stack messiness!\n");

    return 1;
}

